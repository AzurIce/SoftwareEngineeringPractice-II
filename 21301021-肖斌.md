# 2023Âπ¥Êï∞ÊçÆÂ∫ìÂÆûË∑µËØæÁ®ãÊä•Âëä

> 21301021 ËÇñÊñå

## È°πÁõÆ2ÔºöSQL Parser

> È°πÁõÆ‰ΩçÁΩÆÔºö`/codes/sql-parsing`

### 1. ÁêÜËß£

#### > ÁºñËØëÂéüÁêÜÊ¶ÇËø∞

ÂøΩÁï•ÊéâÈ¢ÑÂ§ÑÁêÜ‰ª•ÂèäÈìæÊé•ÁöÑÈÉ®ÂàÜÔºåC/C++ ËØ≠Ë®ÄÁöÑÂÆåÊï¥ÁºñËØëËøáÁ®ãÂèØ‰ª•Áî®‰∏ãÂõæË°®Á§∫Ôºö

```mermaid
flowchart LR
	subgraph Ê∫ê‰ª£Á†Å
        A[main.c]
    end
    
	subgraph Ê±áÁºñ‰ª£Á†Å
        C[main.s]
    end
    
    A --ÁºñËØë -S--> C
    
	subgraph Êú∫Âô®Á†Å
        D[main.o]
    end
    
    C --Ê±áÁºñ -c--> D
    
	Êú∫Âô®Á†Å ---> ÂèØÊâßË°åÁ®ãÂ∫è
	ÂèØÊâßË°åÁ®ãÂ∫è --> z([ËøêË°å])
```

ÁºñËØëÂéüÁêÜ‰∏≠ÁöÑ‚ÄúÁºñËØë‚Äù‰∫åÂ≠ó‰∏éÊ≠§Â§ÑÁöÑ‚ÄúÁºñËØë‚Äù‰∫åÂ≠óÂπ∂‰∏çÊòØ‰∏Ä‰∏™ÊÑèÊÄùÔºåÊ≠§Â§ÑÁöÑÁºñËØëÊòØÂÖ∑‰ΩìÁöÑËøáÁ®ãÔºå‰ªéÊ∫ê‰ª£Á†ÅÂà∞ÊúÄÁªàÁöÑÂèØÊâßË°åÁ®ãÂ∫èÔºåËÄåÁºñËØëÂéüÁêÜ‰∏≠ÁöÑ‚ÄúÁºñËØë‚ÄùÊõ¥Âä†ÂπøÊ≥õÔºå‰∏ÄÂàá‰∏éËß£ÊûêÊüê‰∏ÄÁßçËØ≠Ë®ÄÂπ∂ËΩ¨Âåñ‰∏∫ÂÖ∂‰ªñ‚ÄúËØ≠Ë®Ä‚ÄùÊúâÂÖ≥ÁöÑËøáÁ®ãÈÉΩÁ¶ª‰∏çÂºÄÊ≠§ÂéüÁêÜ„ÄÇ

ÊØîÂ¶Ç python ÁöÑËß£ÈáäÂô®ÔºàËß£Èáä python ‰ª£Á†ÅÂπ∂ËΩ¨Âåñ‰∏∫ÂÖ∑‰ΩìÊåá‰ª§ËøêË°åÔºâÔºåMarkdownÁöÑËß£ÊûêÊ∏≤ÊüìÔºàËß£Êûê Markdown Âπ∂ËΩ¨Âåñ‰∏∫ HTML ËøõË°åÊ∏≤ÊüìÔºâÔºå‰ª•Âèä SQL ÁöÑËß£ÊûêÊâßË°åÔºàËß£Êûê SQL ËØ≠Âè•‰∏∫ÂÖ∑‰ΩìÁöÑÊìç‰ΩúÂπ∂ÊâßË°åÔºâÁ≠âÁ≠â„ÄÇ

ËÄåËøô‰∫õËøáÁ®ãÈÉΩÂèØ‰ª•Â§ßËá¥ÊäΩË±°‰∏∫‰∏§Â§ßÈÉ®ÂàÜÔºö

- ÂâçÁ´ØÈÉ®ÂàÜÔºàFrontendÔºâ

  Ë¥üË¥£Â∞ÜÊ∫ê‰ª£Á†ÅÁªèËøá‰∏ÄÊ≠•Ê≠•ÂàÜÊûêËΩ¨Âåñ‰∏∫‰∏Ä‰∏™ÊäΩË±°ÁöÑÊ†ëÂΩ¢ÁªìÊûÑ ‚Äî‚Äî ÊäΩË±°ËØ≠Ê≥ïÊ†ëÔºàASTÔºâ

- ÂêéÁ´ØÈÉ®ÂàÜÔºàBackendÔºâ

  ÂèØËÉΩÊòØ‰∏™‰ª£Á†ÅÁîüÊàêÂô®Ôºå‰æùÁÖßÊäΩË±°ÁöÑÊ†ëÂΩ¢ÁªìÊûÑÁîüÊàêÂÖ∑‰ΩìÂÆûÈôÖÁöÑËΩ¨ÂåñÁõÆÊ†áÁöÑÊåá‰ª§ÊàñËØ≠Ë®ÄÁ≠â

  ÊàñËÆ∏Ëøò‰ºöÂåÖÂê´‰ºòÂåñÂô®Á≠âÈÉ®ÂàÜ

---

**ÁºñËØëÂô®ÔºàcompilerÔºâ**ÁöÑÂâçÁ´ØÈÉ®ÂàÜÁöÑ‰∏ªË¶ÅÂ∑•‰ΩúÊµÅÁ®ãÂ¶Ç‰∏ãÔºö

- **ËØçÊ≥ïÂàÜÊûêÔºàlexical analysisÔºâ**

  Â∞Ü **Â≠óÁ¨¶Â∫èÂàó** ËΩ¨Êç¢‰∏∫ **ËÆ∞Âè∑ÔºàtokenÔºâÂ∫èÂàó**

- **ËØ≠Ê≥ïÂàÜÊûêÔºàsyntactic analysisÔºå‰πüÂè´ parsingÔºâ**

  Ê†πÊçÆÊüêÁßçÁªôÂÆöÁöÑ **ÊñáÊ≥ï** Áî± **ËÆ∞Âè∑ÔºàtokenÔºâÂ∫èÂàó** ÂæóÂà∞ÂÖ∂ÂØπÂ∫îËØ≠Ê≥ïÁªìÊûÑÔºàËØ≠Ê≥ïÂàÜÊûêÊ†ë„ÄÅÊäΩË±°ËØ≠Ê≥ïÊ†ëÁ≠âÔºâ

- **ËØ≠‰πâÂàÜÊûêÔºàsemnatic analysisÔºâ**

  Á≠õÈÄâÂá∫ÈúÄË¶ÅÊ†πÊçÆ‰∏ä‰∏ãÊñáÊù•ÊâæÂá∫ÁöÑÈîôËØØÔºåÊØîÂ¶ÇÊòØÂê¶ÊúâÂú®‰ΩøÁî®ÂâçÊú™ÂÆö‰πâÁöÑÂèòÈáè„ÄÅËµãÂÄºËØ≠Âè•Á±ªÂûãÊòØÂê¶ÂåπÈÖçÁ≠âÁ≠â

ÁªèËøáËøô‰∏âÊ≠•Á≠õÈÄâ‰∏éËß£ÊûêÔºåÂè™ÊúâÂêàÊ≥ïÁöÑÁ®ãÂ∫èÊâçËÉΩÂ§üÈÄöËøáÂπ∂‰º†ÈÄíÂà∞‰ª£Á†ÅÁîüÊàêÂô®ÔºàÂêéÁ´ØÈÉ®ÂàÜÔºâ„ÄÇ

#### > flex & bison

**flex** ÊòØ‰∏Ä‰∏™Áî®‰∫éÁîüÊàêÂü∫‰∫é C/C++ ÁöÑ **ËØçÊ≥ïÂàÜÊûêÂô®** ÁöÑÁ®ãÂ∫è„ÄÇ

ÂÆÉÁöÑËæìÂÖ•ÊòØ‰∏Ä‰∏™ `.flex`Ôºà`.l`Ôºâ Êñá‰ª∂ÔºåÂÖ∂‰∏≠ÂåÖÂê´ÁùÄ‰∏ÄÂØπÂØπÁî± **Ê≠£ÂàôË°®ËææÂºè** Âíå **C ËØ≠Ë®Ä‰ª£Á†Å** ÁªÑÊàêÁöÑ **ËßÑÂàô**„ÄÇ

ÂÆÉÁöÑËæìÂá∫ÊòØ‰∏Ä‰∏™ C ËØ≠Ë®ÄÊ∫êÊñá‰ª∂ÔºåÂÖ∂‰∏≠‰ºöÂåÖÂê´‰∏Ä‰∏™ `yylex()` ÂáΩÊï∞ÔºåËØ•ÂáΩÊï∞‰ºöÂØπËæìÂÖ•ÁöÑÂ≠óÁ¨¶Â∫èÂàóËøõË°åÊâ´ÊèèÔºåÊ†πÊçÆ **ËßÑÂàô** ‰∏≠ÁöÑ‰∏Ä‰∏™‰∏™ **Ê≠£ÂàôË°®ËææÂºè** ËøõË°åÂåπÈÖçÂπ∂ÊâßË°åÂÖ∂ÂØπÂ∫îÁöÑ **C ËØ≠Ë®Ä‰ª£Á†Å**„ÄÇ

**bison** ÊòØ‰∏Ä‰∏™Áî®‰∫éÁîüÊàêÂü∫‰∫é C/C++ ÁöÑ **ËØ≠Ê≥ïÂàÜÊûêÂô®** ÁöÑÁ®ãÂ∫è„ÄÇ

ÂÆÉÁöÑËæìÂÖ•ÊòØ‰∏Ä‰∏™ `.yacc`Ôºà`.y`ÔºâÊñá‰ª∂ÔºåÂÖ∂‰∏≠ÂåÖÂê´ÁùÄÂØπ‰∏ÄÁ≥ªÂàóÊñáÊ≥ïÁöÑÊèèËø∞Ôºå‰ª•ÂèäÂØπ‰∫éËß£ÊûêÂá∫ÁöÑ‰∏çÂêåÊñáÊ≥ïÊâßË°å‰∏çÂêåÁöÑ‰ª£Á†ÅÔºåÊØè‰∏Ä‰∏™ token ‰ºö‰∏é‰∏Ä‰∏™ÊåáÂÆöÁ±ªÂûãÁöÑÂÄºËøõË°åÁªëÂÆöÔºå‰æø‰∫éÂêéÁª≠Â§ÑÁêÜÔºåÂêåÊó∂‰πüÂèØ‰ª•ÊåáÂÆö‰∏çÂêå token ÁöÑÂ∑¶Âè≥ÁªìÂêàÊÄßÂèä‰ºòÂÖàÁ∫ß„ÄÇ

ËøôÂÑøËÄÖÂèØ‰ª•Áõ∏‰∫íÈÖçÂêàÂÆûÁé∞ÂÆåÊï¥ÁöÑ **ËØçÊ≥ïÂàÜÊûê** Âíå **ËØ≠Ê≥ïÂàÜÊûê** ÁöÑÂ∑•‰Ωú„ÄÇ

### 2. Ë°®ËææÂºèËÆ°ÁÆó

> `code/sql-parsing/calc`

#### > ‰ª£Á†ÅËÆ≤Ëß£

`calc.l`

```c
%option noyywrap
%{
#include "calc.tab.h"
%}
%%
[0-9]+ { yylval = atoi(yytext); return NUMBER; }
[0-9]*"."[0-9]+ { yylval = atof(yytext); return NUMBER; }

[-+*/%=()] { return yytext[0]; }

sin { return SIN; }

. ;
%%

```

`calc.y`

```c
%{
#include <math.h>
#include <stdio.h>
int yylex (void);
void yyerror (char *);

%}
%define api.value.type {double}

%token NUMBER

%token SIN
%left '-' '+'
%left '*' '/' '%'
%precedence NEG   /* negation--unary minus */
%right '^'        /* exponentiation */

%%

input: %empty
     | input line
     ;

line: exp '='  { printf ("\t%lf\n", $1); }

exp:
  NUMBER
| exp '+' exp        { $$ = $1 + $3;      }
| exp '-' exp        { $$ = $1 - $3;      }
| exp '*' exp        { $$ = $1 * $3;      }
| exp '%' exp        { if ($3 == 0) yyerror("division by zero"); $$ = (int)$1 % (int)$3;      }
| exp '/' exp        { if ($3 == 0) yyerror("division by zero"); $$ = $1 / $3;      }
| '-' exp  %prec NEG { $$ = -$2;          }
| exp '^' exp        { $$ = pow($1, $3); }
| '(' exp ')'        { $$ = $2;           }
| SIN '(' exp ')'   { $$ = sin($3); }
;

%%
#include <math.h>

void yyerror(char *s) {
  fprintf(stderr, s);
  fprintf(stderr, "\n");
}

int main() {
    return yyparse();
}

```

Âú® flex Êñá‰ª∂‰∏≠ÂÆö‰πâ‰∫Ü `NUMBER`Ôºå`+`Ôºå`-`Ôºå`*`Ôºå`/`Ôºå`%`Ôºå`=`Ôºå`(`Ôºå`)`Ôºå`SIN` ËøôÂá†‰∏™ tokenÔºå

Âú® bison Êñá‰ª∂‰∏≠ÊåáÂÆö ÂêÑ token ‰∏é `double` Á±ªÂûãÂÄºËøõË°åÁªëÂÆöÔºåÂπ∂ÂÆö‰πâ‰∫Ü `exp`Ôºå`line` Âíå `input` ‰∏â‰∏™ËØ≠Ê≥ïÔºå`exp` ÂèØ‰ª•ÊòØÂçïÁã¨ÁöÑ `NUMBER` ‰πüÂèØ‰ª•ÊòØ `exp` ÁöÑËøêÁÆóÔºåÂØπÂ∫îÁöÑÂåπÈÖç‰ºöËÆ°ÁÆóÂØπÂ∫îË°®ËææÂºèÁöÑÂÄºÂπ∂ËµãÁªôÂΩìÂâçÁöÑ `exp`ÔºåÊúÄÁªàÈÅáÂà∞ `=` ËæìÂá∫„ÄÇ

#### > ÊïàÊûúÂ±ïÁ§∫

![image-20230619145648476](imgs/image-20230619145648476.png)

### 3. SQL Ëß£Êûê

> `code/sql-parsing/sql-parser-full`

‰ª£Á†Å‰øÆÊîπËá™ [hurdad/pmysql: bison & flex sql parser (github.com)](https://github.com/hurdad/pmysql)ÔºàÂéü‰π¶‰ª£Á†ÅÔºâ

#### > ‰ª£Á†ÅËÆ≤Ëß£

`sql-parser.l`

```c
/*
 * Scanner for mysql subset
 * $Header: /usr/home/johnl/flnb/RCS/ch04.tr,v 1.7 2009/05/19 18:28:27 johnl Exp $
 */

%option noyywrap nodefault yylineno case-insensitive
%{
#include "sql-parser.tab.h"
#include <stdarg.h>
#include <string.h>

void yyerror(char *s, ...);

int oldstate;

%}

%x COMMENT
%s BTWMODE

%%

	/* keywords */
ADD     { return ADD; }
ALL     { return ALL; }
ALTER   { return ALTER; }
ANALYZE { return ANALYZE; }

  /* Hack for BETWEEN ... AND ... 
   * return special AND token if BETWEEN seen
   */
<BTWMODE>AND    { BEGIN INITIAL; return AND; }
AND     { return ANDOP; }
ANY     { return ANY; }
AS      { return AS; }
ASC     { return ASC; }
AUTO_INCREMENT  { return AUTO_INCREMENT; }
BEFORE  { return BEFORE; }
BETWEEN { BEGIN BTWMODE; return BETWEEN; }
INT8|BIGINT     { return BIGINT; }
BINARY  { return BINARY; }
BIT     { return BIT; }
BLOB    { return BLOB; }
BOTH    { return BOTH; }
BY      { return BY; }
CALL    { return CALL; }
CASCADE { return CASCADE; }
CASE    { return CASE; }
CHANGE  { return CHANGE; }
CHAR(ACTER)?    { return CHAR; }
CHECK   { return CHECK; }
COLLATE { return COLLATE; }
COLUMN  { return COLUMN; }
COMMENT { return COMMENT; }
CONDITION       { return CONDITION; }
CONSTRAINT      { return CONSTRAINT; }
CONTINUE        { return CONTINUE; }
CONVERT { return CONVERT; }
CREATE  { return CREATE; }
CROSS   { return CROSS; }
CURRENT_DATE    { return CURRENT_DATE; }
CURRENT_TIME    { return CURRENT_TIME; }
CURRENT_TIMESTAMP       { return CURRENT_TIMESTAMP; }
CURRENT_USER    { return CURRENT_USER; }
CURSOR  { return CURSOR; }
DATABASE        { return DATABASE; }
DATABASES       { return DATABASES; }
DATE    { return DATE; }
DATETIME        { return DATETIME; }
DAY_HOUR        { return DAY_HOUR; }
DAY_MICROSECOND { return DAY_MICROSECOND; }
DAY_MINUTE      { return DAY_MINUTE; }
DAY_SECOND      { return DAY_SECOND; }
NUMERIC|DEC|DECIMAL     { return DECIMAL; }
DECLARE { return DECLARE; }
DEFAULT { return DEFAULT; }
DELAYED { return DELAYED; }
DELETE  { return DELETE; }
DESC    { return DESC; }
DESCRIBE        { return DESCRIBE; }
DETERMINISTIC   { return DETERMINISTIC; }
DISTINCT        { return DISTINCT; }
DISTINCTROW     { return DISTINCTROW; }
DIV     { return DIV; }
FLOAT8|DOUBLE   { return DOUBLE; }
DROP    { return DROP; }
DUAL    { return DUAL; }
EACH    { return EACH; }
ELSE    { return ELSE; }
ELSEIF  { return ELSEIF; }
END     { return END; }
ENUM { return ENUM; }
ESCAPED { return ESCAPED; }
EXISTS  { yylval.subtok = 0; return EXISTS; }
NOT[ \t\n]+EXISTS       { yylval.subtok = 1; return EXISTS; }
EXIT    { return EXIT; }
EXPLAIN { return EXPLAIN; }
FETCH   { return FETCH; }
FLOAT4? { return FLOAT; }
FOR     { return FOR; }
FORCE   { return FORCE; }
FOREIGN { return FOREIGN; }
FROM    { return FROM; }
FULLTEXT        { return FULLTEXT; }
GRANT   { return GRANT; }
GROUP   { return GROUP; }
HAVING  { return HAVING; }
HIGH_PRIORITY   { return HIGH_PRIORITY; }
HOUR_MICROSECOND        { return HOUR_MICROSECOND; }
HOUR_MINUTE     { return HOUR_MINUTE; }
HOUR_SECOND     { return HOUR_SECOND; }
IF      { return IF; }
IGNORE  { return IGNORE; }
IN      { return IN; }
INFILE  { return INFILE; }
INNER   { return INNER; }
INOUT   { return INOUT; }
INSENSITIVE     { return INSENSITIVE; }
INSERT  { return INSERT; }
INT4?|INTEGER   { return INTEGER; }
INTERVAL        { return INTERVAL; }
INTO    { return INTO; }
IS      { return IS; }
ITERATE { return ITERATE; }
JOIN    { return JOIN; }
INDEX|KEY       { return KEY; }
KEYS    { return KEYS; }
KILL    { return KILL; }
LEADING { return LEADING; }
LEAVE   { return LEAVE; }
LEFT    { return LEFT; }
LIKE    { return LIKE; }
LIMIT   { return LIMIT; }
LINES   { return LINES; }
LOAD    { return LOAD; }
LOCALTIME       { return LOCALTIME; }
LOCALTIMESTAMP  { return LOCALTIMESTAMP; }
LOCK    { return LOCK; }
LONG    { return LONG; }
LONGBLOB        { return LONGBLOB; }
LONGTEXT        { return LONGTEXT; }
LOOP    { return LOOP; }
LOW_PRIORITY    { return LOW_PRIORITY; }
MATCH   { return MATCH; }
MEDIUMBLOB      { return MEDIUMBLOB; }
MIDDLEINT|MEDIUMINT     { return MEDIUMINT; }
MEDIUMTEXT      { return MEDIUMTEXT; }
MINUTE_MICROSECOND      { return MINUTE_MICROSECOND; }
MINUTE_SECOND   { return MINUTE_SECOND; }
MOD     { return MOD; }
MODIFIES        { return MODIFIES; }
NATURAL { return NATURAL; }
NOT     { return NOT; }
NO_WRITE_TO_BINLOG      { return NO_WRITE_TO_BINLOG; }
NULL    { return NULLX; }
NUMBER  { return NUMBER; }
ON      { return ON; }
ON[ \t\n]+DUPLICATE { return ONDUPLICATE; } /* hack due to limited lookahead */
OPTIMIZE        { return OPTIMIZE; }
OPTION  { return OPTION; }
OPTIONALLY      { return OPTIONALLY; }
OR      { return OR; }
ORDER   { return ORDER; }
OUT     { return OUT; }
OUTER   { return OUTER; }
OUTFILE { return OUTFILE; }
PRECISION       { return PRECISION; }
PRIMARY { return PRIMARY; }
PROCEDURE       { return PROCEDURE; }
PURGE   { return PURGE; }
QUICK   { return QUICK; }
READ    { return READ; }
READS   { return READS; }
REAL    { return REAL; }
REFERENCES      { return REFERENCES; }
REGEXP|RLIKE    { return REGEXP; }
RELEASE { return RELEASE; }
RENAME  { return RENAME; }
REPEAT  { return REPEAT; }
REPLACE { return REPLACE; }
REQUIRE { return REQUIRE; }
RESTRICT        { return RESTRICT; }
RETURN  { return RETURN; }
REVOKE  { return REVOKE; }
RIGHT   { return RIGHT; }
ROLLUP  { return ROLLUP; }
SCHEMA  { return SCHEMA; }
SCHEMAS { return SCHEMAS; }
SECOND_MICROSECOND      { return SECOND_MICROSECOND; }
SELECT  { return SELECT; }
SENSITIVE       { return SENSITIVE; }
SEPARATOR       { return SEPARATOR; }
SET     { return SET; }
SHOW    { return SHOW; }
INT2|SMALLINT   { return SMALLINT; }
SOME    { return SOME; }
SONAME  { return SONAME; }
SPATIAL { return SPATIAL; }
SPECIFIC        { return SPECIFIC; }
SQL     { return SQL; }
SQLEXCEPTION    { return SQLEXCEPTION; }
SQLSTATE        { return SQLSTATE; }
SQLWARNING      { return SQLWARNING; }
SQL_BIG_RESULT  { return SQL_BIG_RESULT; }
SQL_CALC_FOUND_ROWS     { return SQL_CALC_FOUND_ROWS; }
SQL_SMALL_RESULT        { return SQL_SMALL_RESULT; }
SSL     { return SSL; }
STARTING        { return STARTING; }
STRAIGHT_JOIN   { return STRAIGHT_JOIN; }
TABLE   { return TABLE; }
TEMPORARY       { return TEMPORARY; }
TERMINATED      { return TERMINATED; }
TEXT    { return TEXT; }
THEN    { return THEN; }
TIME    { return TIME; }
TIMESTAMP       { return TIMESTAMP; }
INT1|TINYINT    { return TINYINT; }
TINYTEXT        { return TINYTEXT; }
TO      { return TO; }
TRAILING        { return TRAILING; }
TRIGGER { return TRIGGER; }
UNDO    { return UNDO; }
UNION   { return UNION; }
UNIQUE  { return UNIQUE; }
UNLOCK  { return UNLOCK; }
UNSIGNED        { return UNSIGNED; }
UPDATE  { return UPDATE; }
USAGE   { return USAGE; }
USE     { return USE; }
USING   { return USING; }
UTC_DATE        { return UTC_DATE; }
UTC_TIME        { return UTC_TIME; }
UTC_TIMESTAMP   { return UTC_TIMESTAMP; }
VALUES? { return VALUES; }
VARBINARY       { return VARBINARY; }
VARCHAR(ACTER)? { return VARCHAR; }
VARYING { return VARYING; }
WHEN    { return WHEN; }
WHERE   { return WHERE; }
WHILE   { return WHILE; }
WITH    { return WITH; }
WRITE   { return WRITE; }
XOR     { return XOR; }
YEAR    { return YEAR; }
YEAR_MONTH      { return YEAR_MONTH; }
ZEROFILL        { return ZEROFILL; }

	/* numbers */
-?[0-9]+                { yylval.intval = atoi(yytext); return INTNUM; } 

-?[0-9]+"."[0-9]* |
-?"."[0-9]+     |
-?[0-9]+E[-+]?[0-9]+    |
-?[0-9]+"."[0-9]*E[-+]?[0-9]+ |
-?"."[0-9]+E[-+]?[0-9]+ { yylval.floatval = atof(yytext) ;
                                  return APPROXNUM; }
	/* booleans */
TRUE    { yylval.intval = 1; return BOOL; }
UNKNOWN { yylval.intval = -1; return BOOL; }
FALSE   { yylval.intval = 0; return BOOL; }

	/* strings */
'(\\.|''|[^'\n])*'   |
\"(\\.|\"\"|[^"\n])*\"  { yylval.strval = strdup(yytext); return STRING; }

'(\\.|[^'\n])*$      { yyerror("Unterminated string %s", yytext); }
\"(\\.|[^"\n])*$    { yyerror("Unterminated string %s", yytext); }

	/* hex strings */
X'[0-9A-F]+' |  
0X[0-9A-F]+  { yylval.strval = strdup(yytext); return STRING; }

	/* bit strings */
0B[01]+      |
B'[01]+'     { yylval.strval = strdup(yytext); return STRING; }

	/* operators */
[-+&~|^/%*(),.;!]   { return yytext[0]; }

"&&"            { return ANDOP; }
"||"            { return OR; }

"="     { yylval.subtok = 4; return COMPARISON; }
"<=>"   { yylval.subtok = 12; return COMPARISON; }
">="    { yylval.subtok = 6; return COMPARISON; }
">"     { yylval.subtok = 2; return COMPARISON; }
"<="    { yylval.subtok = 5; return COMPARISON; }
"<"     { yylval.subtok = 1; return COMPARISON; }
"!="    |
"<>"    { yylval.subtok = 3; return COMPARISON; }

"<<"    { yylval.subtok = 1; return SHIFT; }
">>"    { yylval.subtok = 2; return SHIFT; }

":="     { return ASSIGN; }

	/* functions */
SUBSTR(ING)?/"(" { return FSUBSTRING; }
TRIM/"("         { return FTRIM; }
DATE_ADD/"("    { return FDATE_ADD; }
DATE_SUB/"("    { return FDATE_SUB; }

	/* check trailing context manually */
COUNT    { int c = input(); unput(c);
           if(c == '(') return FCOUNT;
           yylval.strval = strdup(yytext);
           return NAME; }

	/* names */
[A-Za-z][A-Za-z0-9_]*   { yylval.strval = strdup(yytext);
                          return NAME; }

`[^`/\\.\n]+`           { yylval.strval = strdup(yytext+1);
                          yylval.strval[yyleng-2] = 0;
                          return NAME; }

`[^`\n]*$               { yyerror("unterminated quoted name %s", yytext); }

	/* user variables */
@[0-9a-z_.$]+ |
@\"[^"\n]+\" |
@`[^`\n]+` |
@'[^'\n]+' { yylval.strval = strdup(yytext+1); return USERVAR; }

@\"[^"\n]*$ |
@`[^`\n]*$ |
@'[^'\n]*$ { yyerror("unterminated quoted user variable %s", yytext); }

	/* comments */   
#.*             ;
"--"[ \t].*     ;

"/*"            { oldstate = YY_START; BEGIN COMMENT; }
<COMMENT>"*/"   { BEGIN oldstate; }
<COMMENT>.|\n   ;
<COMMENT><<EOF>> { yyerror("unclosed comment"); }

	/* everything else */
[ \t\n]         /* whitespace */
.               { yyerror("mystery character '%c'", *yytext); }

%%

```

`sql-parser.y`

```c
/*
 * Parser for mysql subset
 * $Header: /usr/home/johnl/flnb/RCS/ch04.tr,v 1.7 2009/05/19 18:28:27 johnl Exp $
 */
%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

void yyerror(char *s, ...);
void emit(char *s, ...);
%}

%union {
        int intval;
        double floatval;
        char *strval;
        int subtok;
}

/* names and literal values */

%token <strval> NAME
%token <strval> STRING
%token <intval> INTNUM
%token <intval> BOOL
%token <floatval> APPROXNUM

/* user @abc names */

%token <strval> USERVAR

/* operators and precedence levels */

%right ASSIGN
%left OR
%left XOR
%left ANDOP
%nonassoc IN IS LIKE REGEXP
%left NOT '!'
%left BETWEEN
%left <subtok> COMPARISON /* = <> < > <= >= <=> */
%left '|'
%left '&'
%left <subtok> SHIFT /* << >> */
%left '+' '-'
%left '*' '/' '%' MOD
%left '^'
%nonassoc UMINUS

%token ADD
%token ALL
%token ALTER
%token ANALYZE
%token AND
%token ANY
%token AS
%token ASC
%token AUTO_INCREMENT
%token BEFORE
%token BIGINT
%token BINARY
%token BIT
%token BLOB
%token BOTH
%token BY
%token CALL
%token CASCADE
%token CASE
%token CHANGE
%token CHAR
%token CHECK
%token COLLATE
%token COLUMN
%token COMMENT
%token CONDITION
%token CONSTRAINT
%token CONTINUE
%token CONVERT
%token CREATE
%token CROSS
%token CURRENT_DATE
%token CURRENT_TIME
%token CURRENT_TIMESTAMP
%token CURRENT_USER
%token CURSOR
%token DATABASE
%token DATABASES
%token DATE
%token DATETIME
%token DAY_HOUR
%token DAY_MICROSECOND
%token DAY_MINUTE
%token DAY_SECOND
%token DECIMAL
%token DECLARE
%token DEFAULT
%token DELAYED
%token DELETE
%token DESC
%token DESCRIBE
%token DETERMINISTIC
%token DISTINCT
%token DISTINCTROW
%token DIV
%token DOUBLE
%token DROP   
%token DUAL 
%token EACH 
%token ELSE
%token ELSEIF
%token END
%token ENUM
%token EXIT
%token EXPLAIN
%token FETCH
%token FLOAT
%token FOR
%token FORCE
%token FOREIGN
%token FROM
%token FULLTEXT
%token GRANT
%token GROUP
%token HAVING
%token HIGH_PRIORITY
%token HOUR_MICROSECOND 
%token HOUR_MINUTE
%token HOUR_SECOND
%token IF
%token IGNORE
%token INFILE
%token INDEX
%token INNER
%token INOUT
%token INSENSITIVE
%token INSERT
%token INT
%token INTEGER
%token INTERVAL
%token INTO
%token ITERATE
%token JOIN
%token KEY
%token KEYS
%token KILL
%token LEADING
%token LEAVE
%token LEFT
%token LIMIT
%token LINES 
%token LOAD 
%token LOCALTIME 
%token LOCALTIMESTAMP
%token LOCK
%token LONG 
%token LONGBLOB
%token LONGTEXT
%token LOOP
%token LOW_PRIORITY
%token MATCH
%token MEDIUMBLOB
%token MEDIUMINT
%token MEDIUMTEXT
%token MINUTE_MICROSECOND
%token MINUTE_SECOND
%token MODIFIES
%token NATURAL
%token NO_WRITE_TO_BINLOG
%token NULLX
%token NUMBER
%token ON
%token ONDUPLICATE
%token OPTIMIZE
%token OPTION
%token OPTIONALLY
%token ORDER
%token OUT
%token OUTER
%token OUTFILE
%token PRECISION
%token PRIMARY
%token PROCEDURE
%token PURGE
%token QUICK
%token READ
%token READS
%token REAL
%token REFERENCES
%token RELEASE
%token RENAME
%token REPEAT
%token REPLACE
%token REQUIRE 
%token RESTRICT
%token RETURN
%token REVOKE 
%token RIGHT
%token ROLLUP
%token SCHEMA
%token SCHEMAS
%token SECOND_MICROSECOND  
%token SELECT
%token SENSITIVE
%token SEPARATOR
%token SET
%token SHOW
%token SMALLINT
%token SOME
%token SONAME
%token SPATIAL
%token SPECIFIC
%token SQL
%token SQLEXCEPTION
%token SQLSTATE
%token SQLWARNING
%token SQL_BIG_RESULT
%token SQL_CALC_FOUND_ROWS
%token SQL_SMALL_RESULT
%token SSL
%token STARTING
%token STRAIGHT_JOIN
%token TABLE
%token TEMPORARY
%token TERMINATED
%token TEXT
%token THEN
%token TIME
%token TIMESTAMP
%token TINYBLOB
%token TINYINT
%token TINYTEXT
%token TO
%token TRAILING
%token TRIGGER 
%token UNDO
%token UNION
%token UNIQUE
%token UNLOCK
%token UNSIGNED
%token UPDATE
%token USAGE
%token USE
%token USING
%token UTC_DATE
%token UTC_TIME
%token UTC_TIMESTAMP
%token VALUES
%token VARBINARY
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE
%token WHILE
%token WITH
%token WRITE
%token YEAR
%token YEAR_MONTH
%token ZEROFILL

%token ESCAPED
%token <subtok> EXISTS /* NOT EXISTS or EXISTS */

/* functions with special syntax */
%token FSUBSTRING
%token FTRIM
%token FDATE_ADD FDATE_SUB
%token FCOUNT

%type <intval> select_opts select_expr_list
%type <intval> val_list opt_val_list case_list
%type <intval> groupby_list opt_with_rollup opt_asc_desc
%type <intval> table_references opt_inner_cross opt_outer
%type <intval> left_or_right opt_left_or_right_outer column_list
%type <intval> index_list opt_for_join

%type <intval> delete_opts delete_list
%type <intval> insert_opts insert_vals insert_vals_list
%type <intval> insert_asgn_list opt_if_not_exists update_opts update_asgn_list
%type <intval> opt_temporary opt_length opt_binary opt_uz enum_list
%type <intval> column_atts data_type opt_ignore_replace create_col_list

%start stmt_list

%%

stmt_list: stmt ';'
  | stmt_list stmt ';'
  ;
  
/**** expressions ****/
   
expr: NAME         { emit("NAME %s", $1); free($1); }
   | NAME '.' NAME { emit("FIELDNAME %s.%s", $1, $3); free($1); free($3); }
   | USERVAR       { emit("USERVAR %s", $1); free($1); }
   | STRING        { emit("STRING %s", $1); free($1); }
   | INTNUM        { emit("NUMBER %d", $1); }
   | APPROXNUM     { emit("FLOAT %g", $1); }
   | BOOL          { emit("BOOL %d", $1); }
   ;
   
expr: expr '+' expr { emit("ADD"); }
   | expr '-' expr { emit("SUB"); }
   | expr '*' expr { emit("MUL"); }
   | expr '/' expr { emit("DIV"); }
   | expr '%' expr { emit("MOD"); }
   | expr MOD expr { emit("MOD"); }
   | '-' expr %prec UMINUS { emit("NEG"); }
   | expr ANDOP expr { emit("AND"); }
   | expr OR expr { emit("OR"); }
   | expr XOR expr { emit("XOR"); }
   | expr '|' expr { emit("BITOR"); }
   | expr '&' expr { emit("BITAND"); }
   | expr '^' expr { emit("BITXOR"); }
   | expr SHIFT expr { emit("SHIFT %s", $2==1?"left":"right"); }
   | NOT expr { emit("NOT"); }
   | '!' expr { emit("NOT"); }
   | expr COMPARISON expr { emit("CMP %d", $2); }
   | '(' expr ')';

/* recursive selects and comparisons thereto */
   | expr COMPARISON '(' select_stmt ')' { emit("CMPSELECT %d", $2); }
   | expr COMPARISON ANY '(' select_stmt ')' { emit("CMPANYSELECT %d", $2); }
   | expr COMPARISON SOME '(' select_stmt ')' { emit("CMPANYSELECT %d", $2); }
   | expr COMPARISON ALL '(' select_stmt ')' { emit("CMPALLSELECT %d", $2); }
   ;

expr:  expr IS NULLX     { emit("ISNULL"); }
   |   expr IS NOT NULLX { emit("ISNULL"); emit("NOT"); }
   |   expr IS BOOL      { emit("ISBOOL %d", $3); }
   |   expr IS NOT BOOL  { emit("ISBOOL %d", $4); emit("NOT"); }

   | USERVAR ASSIGN expr { emit("ASSIGN @%s", $1); free($1); }
   ;

expr: expr BETWEEN expr AND expr %prec BETWEEN { emit("BETWEEN"); }
   ;
   
val_list: expr { $$ = 1; }
   | expr ',' val_list { $$ = 1 + $3; }
   ;

opt_val_list: /* nil */ { $$ = 0; }
   | val_list
   ;

expr: expr IN '(' val_list ')'       { emit("ISIN %d", $4); }
   | expr NOT IN '(' val_list ')'    { emit("ISIN %d", $5); emit("NOT"); }
   | expr IN '(' select_stmt ')'     { emit("CMPANYSELECT 4"); }
   | expr NOT IN '(' select_stmt ')' { emit("CMPALLSELECT 3"); }
   | EXISTS '(' select_stmt ')'      { emit("EXISTSSELECT"); if($1)emit("NOT"); }
   ;
   
/* regular functions */
expr: NAME '(' opt_val_list ')' {  emit("CALL %d %s", $3, $1); free($1); }
   ;

/* functions with special syntax */
expr: FCOUNT '(' '*' ')' { emit("COUNTALL"); }
   | FCOUNT '(' expr ')' { emit(" CALL 1 COUNT"); } 

expr: FSUBSTRING '(' val_list ')'               {  emit("CALL %d SUBSTR", $3); }
   | FSUBSTRING '(' expr FROM expr ')'          {  emit("CALL 2 SUBSTR"); }
   | FSUBSTRING '(' expr FROM expr FOR expr ')' {  emit("CALL 3 SUBSTR"); }

   | FTRIM '(' val_list ')'                     { emit("CALL %d TRIM", $3); }
   | FTRIM '(' trim_ltb expr FROM val_list ')'  { emit("CALL 3 TRIM"); }
   ;

trim_ltb: LEADING { emit("NUMBER 1"); }
   | TRAILING     { emit("NUMBER 2"); }
   | BOTH         { emit("NUMBER 3"); }
   ;

expr: FDATE_ADD '(' expr ',' interval_exp ')' { emit("CALL 3 DATE_ADD"); }
   |  FDATE_SUB '(' expr ',' interval_exp ')' { emit("CALL 3 DATE_SUB"); }
   ;

interval_exp: INTERVAL expr DAY_HOUR { emit("NUMBER 1"); }
   | INTERVAL expr DAY_MICROSECOND   { emit("NUMBER 2"); }
   | INTERVAL expr DAY_MINUTE        { emit("NUMBER 3"); }
   | INTERVAL expr DAY_SECOND        { emit("NUMBER 4"); }
   | INTERVAL expr YEAR_MONTH        { emit("NUMBER 5"); }
   | INTERVAL expr YEAR              { emit("NUMBER 6"); }
   | INTERVAL expr HOUR_MICROSECOND  { emit("NUMBER 7"); }
   | INTERVAL expr HOUR_MINUTE       { emit("NUMBER 8"); }
   | INTERVAL expr HOUR_SECOND       { emit("NUMBER 9"); }
   ;
expr: CASE expr case_list END           { emit("CASEVAL %d 0", $3); }
   |  CASE expr case_list ELSE expr END { emit("CASEVAL %d 1", $3); }
   |  CASE case_list END                { emit("CASE %d 0", $2); }
   |  CASE case_list ELSE expr END      { emit("CASE %d 1", $2); }
   ;

case_list: WHEN expr THEN expr     { $$ = 1; }
         | case_list WHEN expr THEN expr { $$ = $1+1; }
   ;

expr: expr LIKE expr { emit("LIKE"); }
   | expr NOT LIKE expr { emit("LIKE"); emit("NOT"); }
   ;

expr: expr REGEXP expr { emit("REGEXP"); }
   | expr NOT REGEXP expr { emit("REGEXP"); emit("NOT"); }
   ;

expr: CURRENT_TIMESTAMP { emit("NOW"); }
   | CURRENT_DATE       { emit("NOW"); }
   | CURRENT_TIME       { emit("NOW"); }
   ;

expr: BINARY expr %prec UMINUS { emit("STRTOBIN"); }
   ;
   
/* statements: select statement */

stmt: select_stmt { emit("STMT"); }
   ;

select_stmt: SELECT select_opts select_expr_list
                        { emit("SELECTNODATA %d %d", $2, $3); }

    | SELECT select_opts select_expr_list 
     FROM table_references
     opt_where opt_groupby opt_having opt_orderby opt_limit
     opt_into_list { emit("SELECT %d %d %d", $2, $3, $5); }
;

opt_where: /* nil */ 
   | WHERE expr { emit("WHERE"); };

opt_groupby: /* nil */ 
   | GROUP BY groupby_list opt_with_rollup
                             { emit("GROUPBYLIST %d %d", $3, $4); }
;

groupby_list: expr opt_asc_desc
                             { emit("GROUPBY %d",  $2); $$ = 1; }
   | groupby_list ',' expr opt_asc_desc
                             { emit("GROUPBY %d",  $4); $$ = $1 + 1; }
   ;

opt_asc_desc: /* nil */ { $$ = 0; }
   | ASC                { $$ = 0; }
   | DESC               { $$ = 1; }
    ;

opt_with_rollup: /* nil */  { $$ = 0; }
   | WITH ROLLUP  { $$ = 1; }
   ;

opt_having: /* nil */ 
   | HAVING expr { emit("HAVING"); };

opt_orderby: /* nil */ 
   | ORDER BY groupby_list { emit("ORDERBY %d", $3); }
   ;

opt_limit: /* nil */ | LIMIT expr { emit("LIMIT 1"); }
  | LIMIT expr ',' expr             { emit("LIMIT 2"); }
  ; 

opt_into_list: /* nil */ 
   | INTO column_list { emit("INTO %d", $2); }
   ;

column_list: NAME { emit("COLUMN %s", $1); free($1); $$ = 1; }
  | column_list ',' NAME  { emit("COLUMN %s", $3); free($3); $$ = $1 + 1; }
  ;
  
select_opts:                          { $$ = 0; }
| select_opts ALL                 
   { if($1 & 01) yyerror("duplicate ALL option"); $$ = $1 | 01; }
| select_opts DISTINCT            
   { if($1 & 02) yyerror("duplicate DISTINCT option"); $$ = $1 | 02; }
| select_opts DISTINCTROW         
   { if($1 & 04) yyerror("duplicate DISTINCTROW option"); $$ = $1 | 04; }
| select_opts HIGH_PRIORITY       
   { if($1 & 010) yyerror("duplicate HIGH_PRIORITY option"); $$ = $1 | 010; }
| select_opts STRAIGHT_JOIN       
   { if($1 & 020) yyerror("duplicate STRAIGHT_JOIN option"); $$ = $1 | 020; }
| select_opts SQL_SMALL_RESULT    
   { if($1 & 040) yyerror("duplicate SQL_SMALL_RESULT option"); $$ = $1 | 040; }
| select_opts SQL_BIG_RESULT      
   { if($1 & 0100) yyerror("duplicate SQL_BIG_RESULT option"); $$ = $1 | 0100; }
| select_opts SQL_CALC_FOUND_ROWS 
   { if($1 & 0200) yyerror("duplicate SQL_CALC_FOUND_ROWS option"); $$ = 
   $1 | 0200; }
    ;

select_expr_list: select_expr { $$ = 1; }
    | select_expr_list ',' select_expr {$$ = $1 + 1; }
    | '*' { emit("SELECTALL"); $$ = 1; }
    | '(' select_expr_list ')' { $$ = $2; }
    ;

select_expr: expr opt_as_alias ;

opt_as_alias: AS NAME { emit ("ALIAS %s", $2); free($2); }
  | NAME              { emit ("ALIAS %s", $1); free($1); }
  | /* nil */
  ;
  
  table_references:    table_reference { $$ = 1; }
    | table_references ',' table_reference { $$ = $1 + 1; }
    ;

table_reference:  table_factor
  | join_table
;

table_factor:
    NAME opt_as_alias index_hint { emit("TABLE %s", $1); free($1); }
  | NAME '.' NAME opt_as_alias index_hint { emit("TABLE %s.%s", $1, $3);
                               free($1); free($3); }
  | table_subquery opt_as NAME { emit("SUBQUERYAS %s", $3); free($3); }
  | '(' table_references ')' { emit("TABLEREFERENCES %d", $2); }
  ;

opt_as: AS 
  | /* nil */
  ;

join_table:
    table_reference opt_inner_cross JOIN table_factor opt_join_condition
                  { emit("JOIN %d", 100+$2); }
  | table_reference STRAIGHT_JOIN table_factor
                  { emit("JOIN %d", 200); }
  | table_reference STRAIGHT_JOIN table_factor ON expr
                  { emit("JOIN %d", 200); }
  | table_reference left_or_right opt_outer JOIN table_factor join_condition
                  { emit("JOIN %d", 300+$2+$3); }
  | table_reference NATURAL opt_left_or_right_outer JOIN table_factor
                  { emit("JOIN %d", 400+$3); }
  ;

opt_inner_cross: /* nil */ { $$ = 0; }
   | INNER { $$ = 1; }
   | CROSS  { $$ = 2; }
;

opt_outer: /* nil */  { $$ = 0; }
   | OUTER {$$ = 4; }
   ;

left_or_right: LEFT { $$ = 1; }
    | RIGHT { $$ = 2; }
    ;

opt_left_or_right_outer: LEFT opt_outer { $$ = 1 + $2; }
   | RIGHT opt_outer  { $$ = 2 + $2; }
   | /* nil */ { $$ = 0; }
   ;

opt_join_condition: /* nil */
   | join_condition ;

join_condition:
    ON expr { emit("ONEXPR"); }
    | USING '(' column_list ')' { emit("USING %d", $3); }
    ;

index_hint:
     USE KEY opt_for_join '(' index_list ')'
                  { emit("INDEXHINT %d %d", $5, 10+$3); }
   | IGNORE KEY opt_for_join '(' index_list ')'
                  { emit("INDEXHINT %d %d", $5, 20+$3); }
   | FORCE KEY opt_for_join '(' index_list ')'
                  { emit("INDEXHINT %d %d", $5, 30+$3); }
   | /* nil */
   ;

opt_for_join: FOR JOIN { $$ = 1; }
   | /* nil */ { $$ = 0; }
   ;

index_list: NAME  { emit("INDEX %s", $1); free($1); $$ = 1; }
   | index_list ',' NAME { emit("INDEX %s", $3); free($3); $$ = $1 + 1; }
   ;

table_subquery: '(' select_stmt ')' { emit("SUBQUERY"); }
   ;
    
/* statements: delete statement */

stmt: delete_stmt { emit("STMT"); }
   ;

/* single table delete */
delete_stmt: DELETE delete_opts FROM NAME
    opt_where opt_orderby opt_limit
                  { emit("DELETEONE %d %s", $2, $4); free($4); }
;

delete_opts: delete_opts LOW_PRIORITY { $$ = $1 + 01; }
   | delete_opts QUICK { $$ = $1 + 02; }
   | delete_opts IGNORE { $$ = $1 + 04; }
   | /* nil */ { $$ = 0; }
   ;

/* multitable delete, first version */
delete_stmt: DELETE delete_opts
    delete_list
    FROM table_references opt_where
            { emit("DELETEMULTI %d %d %d", $2, $3, $5); }

delete_list: NAME opt_dot_star { emit("TABLE %s", $1); free($1); $$ = 1; }
   | delete_list ',' NAME opt_dot_star
            { emit("TABLE %s", $3); free($3); $$ = $1 + 1; }
   ;

opt_dot_star: /* nil */ | '.' '*' ;

/* multitable delete, second version */
delete_stmt: DELETE delete_opts
    FROM delete_list
    USING table_references opt_where
            { emit("DELETEMULTI %d %d %d", $2, $4, $6); }
;

/* statements: insert statement */

stmt: insert_stmt { emit("STMT"); }
   ;

insert_stmt: INSERT insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { emit("INSERTVALS %d %d %s", $2, $7, $4); free($4); }
   ;

opt_ondupupdate: /* nil */
   | ONDUPLICATE KEY UPDATE insert_asgn_list { emit("DUPUPDATE %d", $4); }
   ;

insert_opts: /* nil */ { $$ = 0; }
   | insert_opts LOW_PRIORITY { $$ = $1 | 01 ; }
   | insert_opts DELAYED { $$ = $1 | 02 ; }
   | insert_opts HIGH_PRIORITY { $$ = $1 | 04 ; }
   | insert_opts IGNORE { $$ = $1 | 010 ; }
   ;

opt_into: INTO | /* nil */
   ;

opt_col_names: /* nil */
   | '(' column_list ')' { emit("INSERTCOLS %d", $2); }
   ;

insert_vals_list: '(' insert_vals ')' { emit("VALUES %d", $2); $$ = 1; }
   | insert_vals_list ',' '(' insert_vals ')' { emit("VALUES %d", $4); $$ = $1 + 1; }

insert_vals:
     expr { $$ = 1; }
   | DEFAULT { emit("DEFAULT"); $$ = 1; }
   | insert_vals ',' expr { $$ = $1 + 1; }
   | insert_vals ',' DEFAULT { emit("DEFAULT"); $$ = $1 + 1; }
   ;
   insert_stmt: INSERT insert_opts opt_into NAME
    SET insert_asgn_list
    opt_ondupupdate
     { emit("INSERTASGN %d %d %s", $2, $6, $4); free($4); }
   ;

insert_asgn_list:
     NAME COMPARISON expr 
       { if ($2 != 4) { yyerror("bad insert assignment to %s", $1); YYERROR; }
       emit("ASSIGN %s", $1); free($1); $$ = 1; }
   | NAME COMPARISON DEFAULT
       { if ($2 != 4) { yyerror("bad insert assignment to %s", $1); YYERROR; }
                 emit("DEFAULT"); emit("ASSIGN %s", $1); free($1); $$ = 1; }
   | insert_asgn_list ',' NAME COMPARISON expr
       { if ($4 != 4) { yyerror("bad insert assignment to %s", $1); YYERROR; }
                 emit("ASSIGN %s", $3); free($3); $$ = $1 + 1; }
   | insert_asgn_list ',' NAME COMPARISON DEFAULT
       { if ($4 != 4) { yyerror("bad insert assignment to %s", $1); YYERROR; }
                 emit("DEFAULT"); emit("ASSIGN %s", $3); free($3); $$ = $1 + 1; }
   ;
   
insert_stmt: INSERT insert_opts opt_into NAME opt_col_names
    select_stmt
    opt_ondupupdate { emit("INSERTSELECT %d %s", $2, $4); free($4); }
  ;

/** replace just like insert **/
stmt: replace_stmt { emit("STMT"); }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
     opt_col_names
     VALUES insert_vals_list
     opt_ondupupdate { emit("REPLACEVALS %d %d %s", $2, $7, $4); free($4); }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME
    SET insert_asgn_list
    opt_ondupupdate
     { emit("REPLACEASGN %d %d %s", $2, $6, $4); free($4); }
   ;

replace_stmt: REPLACE insert_opts opt_into NAME opt_col_names
    select_stmt
    opt_ondupupdate { emit("REPLACESELECT %d %s", $2, $4); free($4); }
  ;
  
/** update **/
stmt: update_stmt { emit("STMT"); }
   ;

update_stmt: UPDATE update_opts table_references
    SET update_asgn_list
    opt_where
    opt_orderby
	opt_limit { emit("UPDATE %d %d %d", $2, $3, $5); }
;

update_opts: /* nil */ { $$ = 0; }
   | insert_opts LOW_PRIORITY { $$ = $1 | 01 ; }
   | insert_opts IGNORE { $$ = $1 | 010 ; }
   ;

update_asgn_list:
     NAME COMPARISON expr 
     { if ($2 != 4) { yyerror("bad update assignment to %s", $1); YYERROR; }
	 emit("ASSIGN %s", $1); free($1); $$ = 1; }
   | NAME '.' NAME COMPARISON expr 
       { if ($4 != 4) { yyerror("bad update assignment to %s", $1); YYERROR; }
	 emit("ASSIGN %s.%s", $1, $3); free($1); free($3); $$ = 1; }
   | update_asgn_list ',' NAME COMPARISON expr
       { if ($4 != 4) { yyerror("bad update assignment to %s", $3); YYERROR; }
	 emit("ASSIGN %s.%s", $3); free($3); $$ = $1 + 1; }
   | update_asgn_list ',' NAME '.' NAME COMPARISON expr
       { if ($6 != 4) { yyerror("bad update  assignment to %s.$s", $3, $5); 
          YYERROR; }
         emit("ASSIGN %s.%s", $3, $5); free($3); free($5); $$ = 1; }
   ;
   
/** create database **/

stmt: create_database_stmt { emit("STMT"); }
   ;

create_database_stmt: 
     CREATE DATABASE opt_if_not_exists NAME 
       { emit("CREATEDATABASE %d %s", $3, $4); free($4); }
   | CREATE SCHEMA opt_if_not_exists NAME 
       { emit("CREATEDATABASE %d %s", $3, $4); free($4); }
   ;

opt_if_not_exists:  /* nil */ { $$ = 0; }
   | IF EXISTS           
       { if(!$2) { yyerror("IF EXISTS doesn't exist"); YYERROR; }
                        $$ = $2; /* NOT EXISTS hack */ }
   ;
   
/** create table **/
stmt: create_table_stmt { emit("STMT"); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   '(' create_col_list ')' { emit("CREATE %d %d %d %s", $2, $4, $7, $5); free($5); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')' { emit("CREATE %d %d %d %s.%s", $2, $4, $9, $5, $7);
                          free($5); free($7); }
   ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   '(' create_col_list ')'
	create_select_statement { emit("CREATESELECT %d %d %d %s", $2, $4, $7, $5); free($5); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME
   create_select_statement { emit("CREATESELECT %d %d 0 %s", $2, $4, $5); free($5); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   '(' create_col_list ')'
   create_select_statement  { emit("CREATESELECT %d %d 0 %s.%s", $2, $4, $5, $7);
                              free($5); free($7); }
    ;

create_table_stmt: CREATE opt_temporary TABLE opt_if_not_exists NAME '.' NAME
   create_select_statement { emit("CREATESELECT %d %d 0 %s.%s", $2, $4, $5, $7);
                          free($5); free($7); }
    ;

opt_temporary:   /* nil */ { $$ = 0; }
   | TEMPORARY { $$ = 1;}
   ;
   
create_col_list: create_definition { $$ = 1; }
    | create_col_list ',' create_definition { $$ = $1 + 1; }
    ;

create_definition: PRIMARY KEY '(' column_list ')'    { emit("PRIKEY %d", $4); }
    | KEY '(' column_list ')'            { emit("KEY %d", $3); }
    | INDEX '(' column_list ')'          { emit("KEY %d", $3); }
    | FULLTEXT INDEX '(' column_list ')' { emit("TEXTINDEX %d", $4); }
    | FULLTEXT KEY '(' column_list ')'   { emit("TEXTINDEX %d", $4); }
    ;
    
create_definition: { emit("STARTCOL"); } NAME data_type column_atts
                   { emit("COLUMNDEF %d %s", $3, $2); free($2); }

column_atts: /* nil */ { $$ = 0; }
    | column_atts NOT NULLX             { emit("ATTR NOTNULL"); $$ = $1 + 1; }
    | column_atts NULLX
    | column_atts DEFAULT STRING        
        { emit("ATTR DEFAULT STRING %s", $3); free($3); $$ = $1 + 1; }
    | column_atts DEFAULT INTNUM        
        { emit("ATTR DEFAULT NUMBER %d", $3); $$ = $1 + 1; }
    | column_atts DEFAULT APPROXNUM     
        { emit("ATTR DEFAULT FLOAT %g", $3); $$ = $1 + 1; }
    | column_atts DEFAULT BOOL          
        { emit("ATTR DEFAULT BOOL %d", $3); $$ = $1 + 1; }
    | column_atts AUTO_INCREMENT        
        { emit("ATTR AUTOINC"); $$ = $1 + 1; }
    | column_atts UNIQUE '(' column_list ')' 
        { emit("ATTR UNIQUEKEY %d", $4); $$ = $1 + 1; }
    | column_atts UNIQUE KEY { emit("ATTR UNIQUEKEY"); $$ = $1 + 1; }
    | column_atts PRIMARY KEY { emit("ATTR PRIKEY"); $$ = $1 + 1; }
    | column_atts KEY { emit("ATTR PRIKEY"); $$ = $1 + 1; }
    | column_atts COMMENT STRING 
        { emit("ATTR COMMENT %s", $3); free($3); $$ = $1 + 1; }
    ;
    
opt_length: /* nil */ { $$ = 0; }
   | '(' INTNUM ')' { $$ = $2; }
   | '(' INTNUM ',' INTNUM ')' { $$ = $2 + 1000*$4; }
   ;

opt_binary: /* nil */ { $$ = 0; }
   | BINARY { $$ = 4000; }
   ;

opt_uz: /* nil */ { $$ = 0; }
   | opt_uz UNSIGNED { $$ = $1 | 1000; }
   | opt_uz ZEROFILL { $$ = $1 | 2000; }
   ;

opt_csc: /* nil */
   | opt_csc CHAR SET STRING { emit("COLCHARSET %s", $4); free($4); }
   | opt_csc COLLATE STRING { emit("COLCOLLATE %s", $3); free($3); }
   ;

data_type:
     BIT opt_length { $$ = 10000 + $2; }
   | TINYINT opt_length opt_uz { $$ = 10000 + $2; }
   | SMALLINT opt_length opt_uz { $$ = 20000 + $2 + $3; }
   | MEDIUMINT opt_length opt_uz { $$ = 30000 + $2 + $3; }
   | INT opt_length opt_uz { $$ = 40000 + $2 + $3; }
   | INTEGER opt_length opt_uz { $$ = 50000 + $2 + $3; }
   | BIGINT opt_length opt_uz { $$ = 60000 + $2 + $3; }
   | REAL opt_length opt_uz { $$ = 70000 + $2 + $3; }
   | DOUBLE opt_length opt_uz { $$ = 80000 + $2 + $3; }
   | FLOAT opt_length opt_uz { $$ = 90000 + $2 + $3; }
   | DECIMAL opt_length opt_uz { $$ = 110000 + $2 + $3; }
   | DATE { $$ = 100001; }
   | TIME { $$ = 100002; }
   | TIMESTAMP { $$ = 100003; }
   | DATETIME { $$ = 100004; }
   | YEAR { $$ = 100005; }
   | CHAR opt_length opt_csc { $$ = 120000 + $2; }
   | VARCHAR '(' INTNUM ')' opt_csc { $$ = 130000 + $3; }
   | BINARY opt_length { $$ = 140000 + $2; }
   | VARBINARY '(' INTNUM ')' { $$ = 150000 + $3; }
   | TINYBLOB { $$ = 160001; }
   | BLOB { $$ = 160002; }
   | MEDIUMBLOB { $$ = 160003; }
   | LONGBLOB { $$ = 160004; }
   | TINYTEXT opt_binary opt_csc { $$ = 170000 + $2; }
   | TEXT opt_binary opt_csc { $$ = 171000 + $2; }
   | MEDIUMTEXT opt_binary opt_csc { $$ = 172000 + $2; }
   | LONGTEXT opt_binary opt_csc { $$ = 173000 + $2; }
   | ENUM '(' enum_list ')' opt_csc { $$ = 200000 + $3; }
   | SET '(' enum_list ')' opt_csc { $$ = 210000 + $3; }
   ;

enum_list: STRING { emit("ENUMVAL %s", $1); free($1); $$ = 1; }
   | enum_list ',' STRING { emit("ENUMVAL %s", $3); free($3); $$ = $1 + 1; }
   ;
   
   create_select_statement: opt_ignore_replace opt_as select_stmt { emit("CREATESELECT %d", $1); }

opt_ignore_replace: /* nil */ { $$ = 0; }
   | IGNORE { $$ = 1; }
   | REPLACE { $$ = 2; }
   ;

/**** set user variables ****/

stmt: set_stmt { emit("STMT"); }
   ;

set_stmt: SET set_list ;

set_list: set_expr | set_list ',' set_expr ;

set_expr:
      USERVAR COMPARISON expr { if ($2 != 4) { yyerror("bad set to @%s", $1); YYERROR; }
                 emit("SET %s", $1); free($1); }
    | USERVAR ASSIGN expr { emit("SET %s", $1); free($1); }
    ;
    
%%
void
emit(char *s, ...)
{
  extern yylineno;

  va_list ap;
  va_start(ap, s);

  printf("rpn: ");
  vfprintf(stdout, s, ap);
  printf("\n");
}

void
yyerror(char *s, ...)
{
  extern yylineno;

  va_list ap;
  va_start(ap, s);

  fprintf(stderr, "%d: error: ", yylineno);
  vfprintf(stderr, s, ap);
  fprintf(stderr, "\n");
}

main(int ac, char **av)
{
  extern FILE *yyin;

  if(ac > 1 && !strcmp(av[1], "-d")) {
    /*yydebug = 1;*/ ac--; av++;
  }

  if(ac > 1 && (yyin = fopen(av[1], "r")) == NULL) {
    perror(av[1]);
    exit(1);
  }

  if(!yyparse())
    printf("SQL parse worked\n");
  else
    printf("SQL parse failed\n");
} /* main */

```

Ê≠§Â§ñÂú® `test` ‰∏ãÂåÖÂê´‰∫ÜÂü∫‰∫é python ÁöÑÊµãËØï‰ª£Á†ÅÔºö

```
test
‚îú‚îÄ‚îÄ gen_tests.py
‚îî‚îÄ‚îÄ query
    ‚îú‚îÄ‚îÄ create_table.sql
    ‚îú‚îÄ‚îÄ create_table_auto_increment.sql
    ‚îú‚îÄ‚îÄ create_table_not_null.sql
    ‚îú‚îÄ‚îÄ create_table_primary_key.sql
    ‚îú‚îÄ‚îÄ delete_from.sql
    ‚îú‚îÄ‚îÄ insert_into.sql
    ‚îú‚îÄ‚îÄ select_all.sql
    ‚îú‚îÄ‚îÄ select_avg.sql
    ‚îú‚îÄ‚îÄ select_column.sql
    ‚îú‚îÄ‚îÄ select_column_alias.sql
    ‚îú‚îÄ‚îÄ select_count_all.sql
    ‚îú‚îÄ‚îÄ select_count_column.sql
    ‚îú‚îÄ‚îÄ select_distinct.sql
    ‚îú‚îÄ‚îÄ select_join_group_by.sql
    ‚îú‚îÄ‚îÄ select_join_group_by_multi.sql
    ‚îú‚îÄ‚îÄ select_join_inner.sql
    ‚îú‚îÄ‚îÄ select_join_left.sql
    ‚îú‚îÄ‚îÄ select_join_right.sql
    ‚îú‚îÄ‚îÄ select_orderby.sql
    ‚îú‚îÄ‚îÄ select_orderby_desc.sql
    ‚îú‚îÄ‚îÄ select_orderby_multi.sql
    ‚îú‚îÄ‚îÄ select_sum.sql
    ‚îú‚îÄ‚îÄ select_table_alias.sql
    ‚îú‚îÄ‚îÄ select_where_alpha.sql
    ‚îú‚îÄ‚îÄ select_where_and.sql
    ‚îú‚îÄ‚îÄ select_where_between.sql
    ‚îú‚îÄ‚îÄ select_where_in.sql
    ‚îú‚îÄ‚îÄ select_where_like.sql
    ‚îú‚îÄ‚îÄ select_where_num.sql
    ‚îú‚îÄ‚îÄ select_where_or.sql
    ‚îú‚îÄ‚îÄ select_where_or_and.sql
    ‚îú‚îÄ‚îÄ sin.sql
    ‚îî‚îÄ‚îÄ update_set_where.sql
```

ÊØè‰∏™ sql Êñá‰ª∂‰øùÂ≠ò‰∫ÜÂØπÂ∫îÁöÑ‰∏ÄÊù° sql ËØ≠Âè•Ôºå‰ΩøÁî® gen_tests.py ÁîüÊàêÊµãËØïËÑöÊú¨Ôºå‰ΩøÁî® pytest Â∞ÜÂØπÂ∫îËØ≠Âè•ÂñÇÁªô sql-parser Âπ∂Ê£ÄÈ™åÊòØÂê¶Ê≠£Á°ÆËß£Êûê

#### > ÊïàÊûúÂ±ïÁ§∫

ÊµãËØïÁªìÊûúÔºö

![image-20230619151131620](imgs/image-20230619151131620.png)

ÂÆû‰æãÂÖ∑‰ΩìËæìÂá∫Ôºö

![image-20230619151243398](imgs/image-20230619151243398.png)

![image-20230619151305540](imgs/image-20230619151305540.png)

### 4. ANTLR

> `code/sql-parsing/antlr`

```antlr4
grammar Expr;		
prog:	expr EOF ;
expr:	expr ('*'|'/') expr
    |	expr ('+'|'-') expr
    |	INT
    |	'(' expr ')'
    ;
NEWLINE : [\r\n]+ -> skip;
INT     : [0-9]+ ;
```

![image-20230619174758260](imgs/image-20230619174758260.png)

![image-20230619174911043](imgs/image-20230619174911043.png)

## È°πÁõÆ3ÔºöLock-table based 2PL

> `code/2pl`

### 1. ÁêÜËß£

ÈîÅË°®Âç≥‰∏Ä‰∏™Â¶Ç‰∏ãÁöÑÁªìÊûÑÔºö

![image-20230619191300786](imgs/image-20230619191300786.png)

Êúâ‰∏Ä‰∏™ÁâπÂÆöÁöÑÁ®ãÂ∫èÁî®‰∫éÁª¥Êä§Ëøô‰∏™ÈîÅË°®ÔºåÂú®ËØ∑Ê±ÇÈîÅÁöÑÊó∂ÂÄôÊ£ÄÊü•ÈîÅË°®ÊÉÖÂÜµÊù•Â∞ÜÂÖ∂ÁΩÆ‰∫é Held Âàó Êàñ Requests ÂàóÔºåÂú®‰∫ãÂä°ÂÆåÊàê‰∫Ü‰ªªÂä°Êó∂Â∞ÜÈîÅÁßªÈô§Âπ∂Ê£ÄÊü• Requests Âàó‰∏≠ÊòØÂê¶ÊúâÈîÅÂèØ‰ª•ÁßªÂä®Âà∞ Held ÂêóÔºåÂπ∂Áªô‰∫àÂØπÂ∫î‰∫ãÂä°ÈîÅ„ÄÇ

---

‰∫åÊÆµÈîÅÂç≥Êúâ‰∏§‰∏™Èò∂ÊÆµÁöÑÈîÅÔºåÂàÜÂà´ÊòØ Growing Phase Âíå Shrinking PhaseÔºåÂú®Ââç‰∏Ä‰∏™Èò∂ÊÆµ‰∫ãÂä°‰ªÖËØ∑Ê±ÇËé∑ÂæóÊñ∞ÁöÑÈîÅËÄå‰∏çÈáäÊîæÈîÅÔºåÂú®Âêé‰∏Ä‰∏™Èò∂ÊÆµ‰∫ãÂä°‰ªÖÈáäÊîæÈîÅËÄå‰∏çËØ∑Ê±ÇËé∑ÂæóÊñ∞ÁöÑÈîÅ„ÄÇ

---

Ê≠ªÈîÅÊ£ÄÊµãÔºö

Âú®ÊØèÊ¨°Ê∑ªÂä†‰∏Ä‰∏™ÈîÅÁöÑÊó∂ÂÄôËã•Êó†Ê≥ïÁõ¥Êé•Ëé∑ÂèñÈîÅÔºàÂç≥Êó†Ê≥ïÁõ¥Êé•ÊèíÂÖ• Held ÂàóÔºâÂàôÊõ¥Êñ∞‰∏Ä‰∏™ÂΩìÂâç‰∫ãÂä°‰æùËµñÁöÑ‰∫ãÂä°ÂàóË°®„ÄÇÊØè‰∏Ä‰∏™‰∫ãÂä°ÈÉΩÁª¥Êä§ÁùÄËøôÊ†∑ÁöÑ‰∏Ä‰∏™ÂàóË°®ÔºåÈÇ£‰πàËøõË°å‰∏ÄÊ¨° DFS ÂàôÂèØÂà§Êñ≠ÊòØÂê¶Â≠òÂú®ÁéØË∑Ø„ÄÇ

Âú®ÊØèÊ¨°ËØ∑Ê±ÇÈîÅÁöÑÊó∂ÂÄôÈÄöËøáÊ£ÄÊü•ÊèíÂÖ•ÂêéÊòØÂê¶ÊúâÁéØÂç≥ÂèØÂà§Êñ≠ÊòØÂê¶Âá∫Áé∞Ê≠ªÈîÅ„ÄÇËã•Âá∫Áé∞Ê≠ªÈîÅÂàôÂ∞ÜÂÖ∂‰∏≠‰∏Ä‰∏™‰∫ãÂä°ÁöÑÈîÅÂÖ®ÈÉ®Êî∂ÂõûÂπ∂Â∞ÜÂÖ∂ÈáçÂêØ„ÄÇ

### 2. ‰ª£Á†ÅËÆ≤Ëß£

ÈîÅÁ±ªÂûã `LockType.go`Ôºö

```go
package main

import (
    "math/rand"
)

// LockType -> read | write
type LockType int

const (
    ReadType LockType = iota
    WriteType
)

func (t LockType) String() string {
    switch t {
    case ReadType:
        return "ReadType"
    case WriteType:
        return "WriteType"
    }
    return "Unknown"
}

func RandLockType() LockType {
    return LockType(rand.Int() % 2);
}

```

‰∏∫‰∫Ü‰æø‰∫é‰ΩøÁî®Â∞ÅË£Ö‰∫Ü‰∏Ä‰∏™ÂàóË°® `task_list.go:7`ÔºàÁúÅÁï•‰∫ÜÈÉ®ÂàÜ‰ª£Á†ÅÔºâÔºö

```go
type TaskList struct {
    tasks []*Task;
    sz    int
}

func (l *TaskList) Add(task *Task)
func (l *TaskList) Remove(task *Task)
func (l *TaskList) Size() int
func (l *TaskList) get(i int) (*Task, error)
func (l *TaskList) HasWriteType() bool
func (l *TaskList) Has(targetTask *Task) bool
```

ÊØè‰∏™ Transaction ÂÜÖÂèØ‰ª•ÂåÖÂê´Â§ö‰∏™ Task `task.go:10`Ôºö

```go
type Task struct {
    TransactionId int
    Id     int
    Target int
    Type   LockType
    Time   time.Duration
    ReqResChan chan int
}
```

Transaction ÁªìÊûÑÂ¶Ç‰∏ã `transaction.go:18`ÔºàÁúÅÁï•‰∫ÜÈÉ®ÂàÜ‰ª£Á†ÅÔºâÔºö

```go
// Transaction
type Transaction struct {
    Id        int
    Tasks     []*Task
    DependTransactions []*Transaction
}

// Ê∑ªÂä†„ÄÅÂà†Èô§‰æùËµñ Transaction
func (t *Transaction) AddDep(depTr *Transaction)
func RemoveDep(depTr *Transaction)
// Ê£ÄÊµãÁéØ
func (t *Transaction) circle(first bool, targetTransaction *Transaction) bool {
    if !first && t == targetTransaction {
        return true
    }
    for _, dependTransaction := range t.DependTransactions {
        if dependTransaction == nil {
            continue
        }
        if dependTransaction.circle(false, targetTransaction) {
            return true
        }
    }
    return false
}
// ÈáçÂêØ
func (t *Transaction) restart() {
    debug()
    for _, task := range t.Tasks {
        scheduer.cancelReqTask(task)
        scheduer.cancelTask(task)
    }
    t.DependTransactions = make([]*Transaction, 0)
    RemoveDep(t)
    // time.Sleep(1 * time.Second)
    debug()
    t.WaitToStart()
}

// TransactionÊâßË°å
func (t *Transaction) WaitToStart() {
    <- startSignal // A Signal to start all Transactions
    log.Println(cyan(fmt.Sprintf("Transaction %v growing phaseüìà", t.Id)))
	// Growing PhaseÔºåÂú®Ëøô‰∏™Èò∂ÊÆµÂè™ËØ∑Ê±ÇËé∑ÂæóÊñ∞ÁöÑÈîÅËÄå‰∏çÈáäÊîæÈîÅ
    for _, task := range t.Tasks {
        fmt.Printf("[WaitToStart] Transaction %v - Target %v %s %v\n", t.Id, task.Target, magenta("getting lock"), task.Type)
        scheduer.reqChan <- task
        res := <- task.ReqResChan // Will block until it's closed
        if res != 1 {
            fmt.Printf(fgRed("[WaitToStart] Transaction %v: Detected deadlock, restarting...\n", t.Id))
            t.restart()
            return
        }
        // fmt.Printf("Transaction %v - Target %v %s\n", t.Id, task.Target, magenta("geted lock"))
    }

    log.Println(cyan(fmt.Sprintf("Transaction %v shrinking phaseüìâ", t.Id)))
	// Shrinking PhaseÔºåÂú®Ëøô‰∏™Èò∂ÊÆµÂè™ËØ∑Ê±ÇÈáäÊîæÈîÅËÄå‰∏çËØ∑Ê±ÇËé∑ÂæóÊñ∞ÁöÑÈîÅÔºåÊå®‰∏™ÊâßË°åÊØè‰∏™ Task
    for _, task := range t.Tasks {
        fmt.Printf("Transaction %v - Target %v %s %v\n", t.Id, task.Target, bgYellow("start"), task.Type)
        time.Sleep(task.Time)
        fmt.Printf("Transaction %v - Target %v %s %v\n", t.Id, task.Target, bgGreen("done"), task.Type)
        scheduer.doneChan <- task
    }
    log.Println(cyan(fmt.Sprintf("Transaction %v done ‚úÖ", t.Id)))
    doneChan <- 1
    // wg.Done()
    // cnt--;
}

```

Áª¥Êä§ÈîÅË°®ÁöÑÊ†∏ÂøÉÈÄªËæë `scheduer.go`Ôºö

```go
package main

import (
	"fmt"
	"log"
)

type Scheduer struct {
    heldTable [64]TaskList;
    reqTable  [64]TaskList;

    reqChan chan *Task
    doneChan chan *Task
}

func NewScheduer() *Scheduer {
    return &Scheduer{
        [64]TaskList{},
        [64]TaskList{},
        make(chan *Task),
        make(chan *Task),
    }
}

func (s *Scheduer) cancelTask(t *Task) {
    if s.heldTable[t.Target].Has(t) {
    fmt.Printf("Canceling task: %v\n", t)
        s.finishTask(t)
    }
}

func (s *Scheduer) cancelReqTask(t *Task) {
    fmt.Printf("Canceling task: %v\n", t)
    s.reqTable[t.Target].Remove(t)
}

func (s *Scheduer) addTask(t *Task) {
    if s.heldTable[t.Target].Size() != 0 && (t.Type == WriteType || s.heldTable[t.Target].HasWriteType()) {
        for i := 0; i < s.heldTable[t.Target].Size(); i++ {
            task, _ := s.heldTable[t.Target].get(i)
            // Update the Dependencies
            transactions[t.TransactionId].AddDep(transactions[task.TransactionId])
        }
        // Check if circled
        if transactions[t.TransactionId].circle(true, transactions[t.TransactionId]) {
            t.ReqResChan <- 0 // DeadLock
            return
        }
        s.reqTable[t.Target].Add(t)
    } else {
        fmt.Printf("[addTask] Transaction %v - Target %v %s %v\n", t.TransactionId, t.Target, magenta("getted lock"), t.Type)
        s.heldTable[t.Target].Add(t)
        t.ReqResChan <- 1
    }
}

func (s *Scheduer) finishTask(t *Task) {
    s.heldTable[t.Target].Remove(t)
    fmt.Printf("Transaction %v - Target %v %s %v\n", t.TransactionId, t.Target, magenta("released lock"), t.Type)
    // fmt.Println("finished: ", t)
    // fmt.Println(s.reqTable[t.Target])

    if s.reqTable[t.Target].Size() == 0 {
        return
    }

    firstReqTask, _ := s.reqTable[t.Target].get(0)
    if firstReqTask.Type == WriteType {
        fmt.Printf("Transaction %v - Target %v %s %v\n", firstReqTask.TransactionId, firstReqTask.Target, magenta("getted lock"), firstReqTask.Type)
        s.reqTable[t.Target].Remove(firstReqTask)
        s.heldTable[t.Target].Add(firstReqTask)
        firstReqTask.ReqResChan <- 1
        return
    }
    for i := 0; i < s.reqTable[t.Target].Size(); i++ {
        reqTask, _ := s.reqTable[t.Target].get(i)
        if reqTask.Type == WriteType {
            continue
        }
        fmt.Printf("Transaction %v - Target %v %s %v\n", firstReqTask.TransactionId, firstReqTask.Target, magenta("getted lock"), firstReqTask.Type)
        s.reqTable[t.Target].Remove(reqTask)
        s.heldTable[t.Target].Add(reqTask)
        reqTask.ReqResChan <- 1
        return
    }
}

func (s *Scheduer) tick() {
    for {
        select {
        case task := <- s.reqChan:
            log.Printf("[scheduer]: Get task request: %v\n", task)
            scheduer.addTask(task)
        case task := <- s.doneChan:
            log.Printf("[scheduer]: Get task done: %v\n", task)
            scheduer.finishTask(task)
        // default:
        //     fmt.Println(cnt)
        //     time.Sleep(2 * time.Second)
        }
    }
}

```



### 3. ÊïàÊûúÂ±ïÁ§∫

ÈöèÊú∫ÁîüÊàê 10 ‰∏™‰∫ãÂä°Ôºö

![image-20230619191842074](imgs/image-20230619191842074.png)

![image-20230619191856539](imgs/image-20230619191856539.png)

![image-20230619191911762](imgs/image-20230619191911762.png)

![image-20230619191923545](imgs/image-20230619191923545.png)

---

Â∏¶ÊúâÊ≠ªÈîÅÁöÑ‰∏Ä‰∏™‰æãÂ≠êÔºö

![image-20230619192025337](imgs/image-20230619192025337.png)



## È°πÁõÆ4ÔºöWeb

> `code/web`

### 1. ÁêÜËß£

#### > È°πÁõÆÊûÑÊàê

ÂâçÁ´ØÂü∫‰∫é nodejs +HTML + CSS ÈááÁî® svelte Ê°ÜÊû∂Âíå typescript„ÄÇ

‰ΩøÁî®‰∫Ü svelte ÁöÑ smui ÁªÑ‰ª∂Â∫ìÔºå‰ª•ÂèäÂéüÂ≠êÂåñ CSS Ê°ÜÊû∂ unocss„ÄÇ

ÊûÑÂª∫Âá∫ÈùôÊÄÅÈ°µÈù¢„ÄÇ

ÂêéÁ´ØÂü∫‰∫é GolangÔºåÂâçÁ´ØÊûÑÂª∫Âá∫ÁöÑÈùôÊÄÅÈ°µÈù¢ÈÄöËøá statik Â∫ìÂµåÂÖ•Âà∞ go ÊûÑÂª∫Âá∫ÁöÑ‰∫åËøõÂà∂Êñá‰ª∂‰∏≠Ôºå‰ΩøÁî® gin Ê°ÜÊû∂Êê≠Âª∫Ë∑ØÁî±„ÄÅhttp handler Á≠â„ÄÇ

ÂâçÁ´ØÈÄöËøá axios Â∫ìÂèëÈÄÅ http ËØ∑Ê±Ç‰∏éÂêéÁ´Ø‰∫§ÊµÅ„ÄÇ

---

#### > ‰∏âÂ±ÇÊû∂ÊûÑ

**MVC** ÂÖ®Áß∞ Model-View-ControllerÔºåÊ≠£Â¶ÇÂêçÁß∞ÊâÄÁ§∫ÔºåÂ∞ÜÊï¥‰∏™Â∫îÁî®ÁöÑÁªìÊûÑÊãÜÂàÜ‰∏∫‰∏âÂ±ÇÔºö

- ModelÔºöË¥üË¥£Êï∞ÊçÆ
- ControllerÔºöË¥üË¥£Êï∞ÊçÆ‰∫§‰∫í„ÄÅÂìçÂ∫îËØ∑Ê±Ç
- ViewÔºöË¥üË¥£ËßÜÂõæ

ÂâçÁ´ØÂÆåÊàê View ÁöÑÈÉ®ÂàÜÔºåÂÖ∂‰ΩôÈÉ®ÂàÜ‰∫§ÁªôÂêéÁ´Ø„ÄÇ

ËÄåÂêéÁ´ØÂ∞ÜÈÄªËæëÁªÜÂàÜÔºåÂèØ‰ª•ÂàÜÂá∫‰∫ÜÂ¶Ç‰∏ãÂá†Â±ÇÔºö

- routerÔºöË∑ØÁî±
- controllerÔºöÊ†∏È™åÊï∞ÊçÆ„ÄÅÂèÇÊï∞ÊòØÂê¶ÂêàÊ≥ï
- serviceÔºö‰ªé model Â±ÇÊãøÂà∞Êï∞ÊçÆÂÜçËøîÂõû
- modelÔºö‰∏éÊï∞ÊçÆÂ∫ìËøõË°åÊï∞ÊçÆ‰∫§‰∫í

ËÄåÊàëÁöÑÂÆûÁé∞ÈÄöËøáÊé•Âè£ÁöÑÊñπÂºèËá™Âä®ÂÆûÁé∞‰∫Ü controller ‰∏é service ‰πãÈó¥ÁöÑÊò†Â∞ÑÔºåËØ¶ÁªÜËßÅ‰ª£Á†ÅËÆ≤Ëß£„ÄÇ

#### > ÁôªÂΩïÊéßÂà∂

ÁôªÈôÜÈ™åËØÅÈÄöÂ∏∏Êúâ‰ª•‰∏ãÂá†ÁßçÊñπÊ≥ï

1. Âü∫‰∫é cookie

   Âú®Âü∫‰∫é cookie ÁöÑË∫´‰ªΩÈ™åËØÅ‰∏≠ÔºåÂΩìÁî®Êà∑ÊàêÂäüÁôªÂΩïÂêéÔºåÊúçÂä°Âô®‰ºöÂ∞ÜÂ∏¶ÊúâË∫´‰ªΩÈ™åËØÅ‰ø°ÊÅØÁöÑ cookie ÂèëÈÄÅÁªôÂÆ¢Êà∑Á´Ø„ÄÇ‰ª•ÂêéËÆøÈóÆËØ•ÁΩëÁ´ôÊó∂ÔºåÂÆ¢Êà∑Á´ØÁöÑÊµèËßàÂô®‰ºöËá™Âä®ÂèëÈÄÅËØ• cookieÔºåÊó†ÈúÄÁî®Êà∑ÈáçÊñ∞ÁôªÂΩï„ÄÇ

   ‰∏é Session ‰∏çÂêåÔºåCookie Âú®ÂÆ¢Êà∑Á´ØÂ≠òÂÇ®ÔºåÂèØ‰ª•Âú®ÊµèËßàÂô®ÂÖ≥Èó≠ÂíåÈáçÊñ∞ÂêØÂä®ÂêéÁªßÁª≠ÂèëÈÄÅ„ÄÇCookie ‰º†ÈÄíÁöÑ‰ø°ÊÅØÈÄöÂ∏∏ÊòØÁºñÁ†Å‰∏∫ Base64 ÊàñÂä†ÂØÜÁöÑÔºå‰ΩÜ Cookie Êú¨Ë∫´‰∏çÂÆâÂÖ®ÔºåÂèØËÉΩ‰ºöË¢´ÂÆ¢Êà∑Á´ØÊàñÁ¨¨‰∏âÊñπÁ™ÉÂèñ„ÄÇ

2. Âü∫‰∫é session Âíå cookie

   Âü∫‰∫é session ÁöÑËÆ§ËØÅÊòØÊåáÂΩìÁî®Êà∑È¶ñÊ¨°ÁôªÂΩïÊàêÂäüÂêéÔºåÊúçÂä°Âô®Â∞Ü‰∏∫Áî®Êà∑ÂàõÂª∫‰∏Ä‰∏™ sessionÔºå‰∏∫ÂÖ∂ÂàÜÈÖç‰∏Ä‰∏™ÂîØ‰∏ÄÁöÑ session ID Âπ∂Â∞ÜËØ• ID ÂÇ®Â≠òÂú® cookie ‰∏≠„ÄÇÂà†Èô§ cookie Êó∂Ôºåsession ID ‰πü‰ºöË¢´Âà†Èô§„ÄÇ

   ‰πãÂêéÔºåÁî®Êà∑ËØ∑Ê±ÇÊúçÂä°Âô®Êó∂‰ºöÂ∞ÜËØ• session ID ‰∏éÂÖ∂ÂèëÈÄÅËá≥ÊúçÂä°Âô®„ÄÇÊúçÂä°Âô®‰ΩøÁî®ËØ• session ID Êù•Êü•ÊâæÊúçÂä°Âô®‰∏≠ÁöÑ session Êï∞ÊçÆÔºåÂπ∂‰ª•Ê≠§ËøõË°åË∫´‰ªΩÈ™åËØÅ„ÄÇ session ÈÄöÂ∏∏‰ºöÂú®ÊúçÂä°Âô®Á´ØÂ≠òÂÇ®ÔºåÂÆÉÂèØ‰ª•Âú®ÊúçÂä°Âô®ÈáçÂêØÂêéÊÅ¢Â§çÂπ∂‰øùÊåÅÁî®Êà∑Áä∂ÊÄÅ„ÄÇ

3. Âü∫‰∫é JWT Token Âíå localStorage

   JWT TokenÁî±‰∏â‰∏™ÈÉ®ÂàÜÁªÑÊàêÔºöÂ§¥ÈÉ®ÔºåË¥üËΩΩÂíåÁ≠æÂêç„ÄÇÂ§¥ÈÉ®ÂåÖÂê´Âä†ÂØÜÁÆóÊ≥ïÂíåtokenÁ±ªÂûãÔºõË¥üËΩΩÊòØÂåÖÂê´Ë∫´‰ªΩÈ™åËØÅ‰ø°ÊÅØÁöÑ JSON Êï∞ÊçÆÔºõÁ≠æÂêçÁî®‰∫éÈ™åËØÅ token ÁöÑÊúâÊïàÊÄßÂíåÂÆåÊï¥ÊÄß„ÄÇ

   ÂΩìÁî®Êà∑È¶ñÊ¨°ÁôªÂΩïÊàêÂäüÂêéÔºåÊúçÂä°Âô®‰ºö‰ΩøÁî®Êüê‰∫õÁÆóÊ≥ï‰∏∫ÂÖ∂ÂàÜÈÖç‰∏Ä‰∏™ JWT Token„ÄÇÂèØ‰ª•Âú®ÂâçÁ´ØÂ∞ÜÊ≠§ token Â≠òÂÇ®Âú®ÊµèËßàÂô®ÁöÑ localStorage Êàñ sessionStorage ‰∏≠„ÄÇ‰ª•ÂêéÔºåÁî®Êà∑ÊØèÊ¨°ËØ∑Ê±ÇÊúçÂä°Âô®Êó∂ÔºåÂú®ËØ∑Ê±ÇÂ§¥‰∏≠ÂåÖÂê´ËØ• JWT TokenÔºåÊúçÂä°Âô®‰ΩøÁî®ÂêåÊ†∑ÁöÑÁÆóÊ≥ïÈ™åËØÅ Token ÁöÑÊúâÊïàÊÄßÂíåÂÆåÊï¥ÊÄßÔºåÂπ∂‰æùÊ≠§ËøõË°åË∫´‰ªΩÈ™åËØÅ„ÄÇÁî±‰∫é Token Ë¢´Âä†ÂØÜÂíåÁ≠æÂêçÔºåÂÆ¢Êà∑Á´ØÊó†Ê≥ïËá™Ë°å‰øÆÊîπ„ÄÇ

   Âü∫‰∫é JWT Token ÁöÑÈ™åËØÅÊñπÊ≥ïÁõ∏ÂØπ‰∫é session Âíå cookie Êõ¥‰∏∫ÁÅµÊ¥ªÔºåÂõ†‰∏∫ÊúçÂä°Âô®‰∏çÂøÖÂú®ÊØè‰∏™Áî®Êà∑‰ºöËØù‰∏≠Â≠òÂÇ®Áä∂ÊÄÅ„ÄÇËøô‰ΩøÂæó JWT Êàê‰∏∫‰∏ÄÁßç‰ΩøÁî®È¢ëÁéáËæÉÈ´òÁöÑÈ™åËØÅÊñπÊ°à„ÄÇ

ÊÄªÁöÑÊù•ËØ¥ÔºåÂü∫‰∫é session ÂíåÂü∫‰∫é cookie ‰æùËµñ‰∫éÊúçÂä°Âô®Â≠òÂÇ®Áä∂ÊÄÅÔºåËÄåÂü∫‰∫é JWT Token ‰∏çÈúÄË¶ÅÂ≠òÂÇ®Áä∂ÊÄÅ„ÄÇ

ÈÄâÊã©‰∫ÜÂü∫‰∫é JWT Token ÁöÑÊñπÂºè„ÄÇ

#### > ‰ΩøÁî® ÂìàÂ∏å + Âä†Áõê Â≠òÂÇ®ÂØÜÁ†ÅÂä†Âº∫ÂÆâÂÖ®ÊÄß

##### 1ÔºâÊòéÊñá

Áî®Êà∑ÂêçÂíåÂØÜÁ†Å‰ª•ÊòéÊñáÊñπÂºèÂ≠òÂÇ®Âú®Êï∞ÊçÆÂ∫ì‰∏≠ÔºåËã•Êï∞ÊçÆÂ∫ìË¢´Êãø‰∏ãÔºåÈÇ£‰πàÊîªÂáªËÄÖÂ∞±ÂèØ‰ª•Áõ¥Êé•ÊãøÂà∞ÊâÄÊúâ‰∫∫ÁöÑÂØÜÁ†Å„ÄÇ

```
|User|Password|
|  1 |  P(1)  |
|  2 |  P(2)  |
|  3 |  P(3)  |
```

##### 2Ôºâ‰ΩøÁî®ÂìàÂ∏åÁÆóÊ≥ï

ÂìàÂ∏åÁÆóÊ≥ïÁöÑÊú¨Ë¥®ÊòØÂØπÊï∞ÊçÆËøõË°å‰∏Ä‰∏™‰∏çÈáçÂ§çÁöÑÂçïÂ∞Ñ„ÄÇ

```
P(1) -> P'(1)
P(2) -> P'(2)
P(3) -> P'(3)
...
```

ÊúçÂä°Á´ØÂè™Â≠òÂÇ®ÁªèËøáÂìàÂ∏åÂêéÁöÑÂØÜÁ†Å„ÄÇÂÆ¢Êà∑Á´ØÂú®ÁôªÈôÜÊó∂ÂèëÈÄÅÂéüÊú¨ÁöÑÂØÜÁ†ÅÔºåÂπ∂Âú®ÊúçÂä°Á´Ø‰ΩøÁî®ÂêåÊ†∑ÁöÑÂìàÂ∏åÁÆóÊ≥ïËÆ°ÁÆóÔºå‰∏éÂìàÂ∏åÂêéÁöÑÂØÜÁ†ÅËøõË°åÊØîÂØπ„ÄÇ

```
|User|HashedPassword|
|  1 |     P'(1)    |
|  2 |     P'(2)    |
|  3 |     P'(3)    |
```

ËøôÊ†∑ÔºåËã•Êï∞ÊçÆÂ∫ìË¢´Êãø‰∏ãÔºåÊîªÂáªËÄÖÊãøÂà∞ÁöÑÊòØ P'ÔºåËÄå P' ‰∏çËÉΩË¢´Áõ¥Êé•ÊãøÊù•ÁôªÂΩïÔºàÂõ†‰∏∫ P' ÁªèËøá‰∏ÄÊ¨°ÂìàÂ∏å ‰∏çËÉΩ‰æùÁÑ∂Á≠â‰∫é P'ÔºâÔºåÂêåÊó∂‰πü‰∏çËÉΩÂèçÂêëÊ±ÇÂæó P„ÄÇ
Â¶ÇÊ≠§ÔºåÊîªÂáªËÄÖÂøÖÈ°ªÊûö‰∏æ PÔºåÁõ¥Ëá≥ÊâæÂà∞‰∏Ä‰∏™‰ΩøÁî®Áõ∏ÂêåÂìàÂ∏åÁÆóÊ≥ïÊ≠£ÂêëËÆ°ÁÆóÂêéÁªìÊûú‰∏é P' Áõ∏ÂêåÁöÑ PÔºåÊâçÊòØÁúüÊ≠£ÁöÑÂØÜÁ†Å„ÄÇ

‰ΩÜÊòØ‰ºóÊâÄÂë®Áü•Ôºå‰∏áÁâ©ÁöÜÂèØÊâìË°®„ÄÇ
‰Ωú‰∏∫‰∫∫Á±ªÔºåÂ§ßÂ§öÊï∞‰∫∫ËÆæÁΩÆÁöÑÂØÜÁ†ÅÈÉΩÁº∫‰πèÈöèÊú∫ÊÄßÔºåÊØîÂ¶ÇÂßìÂêçÁº©ÂÜô+ÁîüÊó•„ÄÅÊõ¥ÊúâÁîöËÄÖÂ∞±ÊòØ‰∏Ä‰∏™ `123456`„ÄÇÊîªÂáªËÄÖÂèØ‰ª•‰ΩøÁî®‰∏Ä‰∏™Â∫ûÂ§ßÁöÑÂ∏∏ËßÅÂØÜÁ†ÅÂ∫ìÂπ∂‰ΩøÁî®Áõ∏ÂêåÁöÑÂìàÂ∏åÁÆóÊ≥ïÈ¢ÑÂÖàËÆ°ÁÆóÂá∫‰∏ÄÂ§ßÂº†Ë°®ÔºåÁõ¥Êé•‰∏é P' ËøõË°åÂåπÈÖç„ÄÇ

##### 3ÔºâÂä†Áõê

Â∞Ü‰∏çÂêåÁî®Êà∑ÁöÑÂØÜÁ†ÅÈôÑÂä†‰∏ä‰∏çÂêåÁöÑÈöèÊú∫‰∏≤Êù•ÂΩ¢ÊàêÊñ∞ÁöÑÂØÜÁ†ÅÔºå‰øùÂ≠òÂØπËøô‰∏™ÂØÜÁ†ÅËøõË°åÂìàÂ∏åÁöÑÁªìÊûú‰Ωú‰∏∫Â≠òÂÇ®ÁöÑÂØÜÁ†Å„ÄÇÔºà‰∏çÂêåÁöÑÁõêÂÄº‰πü‰øùÂ≠òÂú®ÊúçÂä°Á´Ø‰∏≠Ôºâ

```
S(1) + P(1) -> SP(1) -> SP'(1)
S(2) + P(2) -> SP(2) -> SP'(2)
S(3) + P(3) -> SP(3) -> SP'(3)
...
```

ËøôÊ†∑Ôºå‰∏ÄÊù•Â¢ûÂº∫‰∫ÜÁî®Êà∑ÂØÜÁ†ÅÁöÑÈöèÊú∫ÊÄßÔºåÊèêÈ´ò‰∫ÜÊâìË°®ÈöæÂ∫¶Ôºå
Âè¶‰∏ÄÊñπÈù¢ÊîªÂáªËÄÖËÆ°ÁÆóÂá∫ÁöÑ‰∏ÄÂº†Ë°®Âè™ËÉΩÈíàÂØπ‰∏Ä‰∏™ÁõêÂÄºÔºåÂ∞ÜÂØπÁæ§‰ΩìÁöÑÊîªÂáªËΩ¨Âåñ‰∏∫‰∫ÜÂØπ‰∏Ä‰∏™‰∏™‰ΩìÁöÑÊîªÂáªÔºåÂ§ßÂ§ßÂ¢ûÂä†‰∫ÜÊîªÂáª‰ª£‰ª∑„ÄÇ

```
|User| Salt |HashedPasswordWithSalt|
|  1 | S(1) |        SP'(1)        |
|  2 | S(2) |        SP'(2)        |
|  3 | S(3) |        SP'(3)        |
```

#### > ORM

ORM ÂÖ®Áß∞ Object Relation MappingÔºàÂØπË±°ÂÖ≥Á≥ªÊò†Â∞ÑÔºâÊòØ‰∏ÄÁßçÂ∞ÜÈù¢ÂêëÂØπË±°ÁºñÁ®ãËØ≠Ë®ÄÂíåÂÖ≥Á≥ªÊï∞ÊçÆÂ∫ì‰πãÈó¥Êï∞ÊçÆÁöÑÁõ∏‰∫íËΩ¨Êç¢ÁöÑÊäÄÊúØ„ÄÇORM ÈÄöËøáÂ∞ÜÂØπË±°Êò†Â∞ÑÂà∞ÂÖ≥Á≥ªÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑË°®„ÄÅË°åÂíåÂàóÔºåÂ∞ÜÈù¢ÂêëÂØπË±°ÁöÑÊï∞ÊçÆÊ®°Âûã‰∏éÂÖ≥Á≥ªÂûãÊï∞ÊçÆÂ∫ì‰πãÈó¥Âª∫Á´ã‰∫Ü‰∏ÄÁßçËá™Âä®ÂåñÊò†Â∞Ñ„ÄÇ

ORM ÊäÄÊúØÂ∞ÜÂ∫îÁî®Á®ãÂ∫è‰∏≠ÁöÑÂØπË±°‰∏éÂÖ≥Á≥ªÊï∞ÊçÆÂ∫ìËøõË°åÊò†Â∞ÑÔºåÂºÄÂèë‰∫∫ÂëòÂè™ÈúÄÁºñÂÜô‰ΩøÁî®ÂØπË±°ÁöÑ‰ª£Á†ÅÔºåËÄå‰∏çÂøÖÂÖàÁºñÂÜôÂ§çÊùÇÁöÑ SQL ËØ≠Âè•Ôºå‰ªéËÄåËäÇÁúÅ‰∫ÜÂºÄÂèëÊó∂Èó¥ÂíåÊàêÊú¨ÔºåËøòÊèêÈ´ò‰∫Ü‰ª£Á†ÅÂèØËØªÊÄßÂíåÂèØÁª¥Êä§ÊÄß„ÄÇ

ORM ÊäÄÊúØÂèØ‰ª•Ëá™Âä®ÊâßË°å‰ª•‰∏ã‰ªªÂä°Ôºö

1. Âª∫Á´ãÂØπË±°ÂíåÊï∞ÊçÆÂ∫ìË°®‰πãÈó¥ÁöÑÊò†Â∞ÑÂÖ≥Á≥ª
2. Ëá™Âä®ÂàõÂª∫Ë°®Âíå‰øÆÊîπË°®ÁªìÊûÑ
3. Ëá™Âä®ÁîüÊàê SQL ËØ≠Âè•Ôºå‰ªéËÄåÈÅøÂÖç‰∫ÜÂºÄÂèë‰∫∫ÂëòÈúÄË¶ÅÁºñÂÜôÂ§çÊùÇÁöÑ SQL ËØ≠Âè•
4. Â∞ÜË°®ËÆ∞ÂΩïÊò†Â∞Ñ‰∏∫ÂØπË±°ÂÆû‰æãÔºå‰ªéËÄåÂ∞ÜÁºñÁ®ãËØ≠Ë®Ä‰∏≠ÁöÑÂØπË±°Áõ¥Êé•‰∏éÊï∞ÊçÆÂ∫ìËøõË°å‰∫§‰∫í

ËÄåÁî±‰∫éÊú¨È°πÁõÆÊòØÊï∞ÊçÆÂ∫ìËØæÁ®ãÁöÑÂÆûËÆ≠È°πÁõÆÔºå‰∏∫‰∫ÜÈîªÁÇº SQL ÁöÑÁºñÂÜôËÉΩÂäõÔºåÂπ∂Ê≤°ÊúâÁõ¥Êé•‰ΩøÁî®Áé∞ÊàêÁöÑ ORM Â∫ìÔºàÊØîÂ¶Ç GormÔºâÔºåËÄåÊòØÈòÖËØª‰∫ÜÈÉ®ÂàÜ Gorm ÁöÑÊ∫êÁ†ÅÔºåÂπ∂ÁªìÂêàËá™Â∑±ÁöÑÁêÜËß£ÊâãÊêì‰∫ÜÁÆÄÂçïÁöÑ ORM ÂäüËÉΩ„ÄÇ

### 2. ‰ª£Á†ÅËÆ≤Ëß£

#### > ‰∏âÂ±ÇÊû∂ÊûÑÁöÑÁÆÄÂåñ

ÈÄöËøáËÆæËÆ° Service Êé•Âè£ `server/service/service.go:13`Ôºö

```go
type Service interface {
	Handle(c *gin.Context) (any, error)
}

// Handler is a controller bridge between router and service
func Handler(s Service) gin.HandlerFunc {
	return func(c *gin.Context) {
		// First bind the JSON to the service
		err := c.ShouldBindJSON(s)
		if err != nil && err != io.EOF {
			c.JSON(http.StatusBadRequest, serializer.ErrorResponse(err))
			return
		}

		// Then invoke the Handle method of the server
		res, err := s.Handle(c)
		if err != nil {
			log.Println(err.Error())
			c.JSON(http.StatusBadRequest, serializer.ErrorResponse(err))
		} else {
			log.Println("StatusOK")
			c.JSON(http.StatusOK, serializer.Response(res))
		}
	}
}

```

Â∞ÜÂéüÊú¨ controller Â±ÇË¶ÅÂÆåÊàêÁöÑÂ∑•‰ΩúËá™Âä®ÂÆåÊàêÔºàÊ†∏È™åÊï∞ÊçÆ„ÄÅÂèÇÊï∞ÊòØÂê¶ÂêàÊ≥ïÔºâÔºå‰∫éÊòØÂèØ‰ª•Áõ¥Êé•Âú® router Â±Ç‰æøÊç∑Âú∞ÈÄöËøáÂú®Êª°Ë∂≥ Service Êé•Âè£ÁöÑÁ±ªÂûãÂ§ñÂ•ó‰∏Ä‰∏™ `Handler` ÊñπÊ≥ïÁõ¥Êé•ÁîüÊàê controller ‰ª£Á†ÅÔºåË∑ØÁî±‰ª£Á†ÅÂ¶Ç‰∏ã `server/router.go:12`Ôºö

```go
func InitRouter() *gin.Engine {
    r := gin.Default()

	config := cors.DefaultConfig()
	config.ExposeHeaders = []string{"Authorization"}
	config.AllowCredentials = true
	config.AllowAllOrigins = true
	config.AllowHeaders = []string{"Origin", "Content-Length", "Content-Type", "Authorization"}
	r.Use(cors.New(config))

    // static file middleware
    r.Use(middlewares.Frontend(bootstrap.StaticFS))
    api := r.Group("api")
    {
        // No login required
        user := api.Group("user")
        {
            // Login Service
            user.POST("login", service.Handler(&service.LoginService{}))
            // Register Service
            user.POST("register", service.Handler(&service.RegisterService{}))
        }

        auth := api.Group("")
        auth.Use(middlewares.JWTAuth())
        {
            // course
            course := auth.Group("course")
            {
                course.POST("", service.Handler(&service.CreateCourseService{}))
                course.PUT("", service.Handler(&service.UpdateCourseService{}))
                course.GET("", service.Handler(&service.GetCoursesService{}))
                course.GET("joined", service.Handler(&service.GetJoinedCoursesService{}))
                course.GET("created", service.Handler(&service.GetCreatedCoursesService{}))
                course.POST("join", service.Handler(&service.JoinCourseService{}))
                course.POST("exit", service.Handler(&service.ExitCourseService{}))
            }

            auth.POST("sql", service.Handler(&service.SQLService{}))
        }
    }

    return r
}
```

#### > ÊâãÊêì ORM

Âú® Golang ‰∏≠ÊòØÊîØÊåÅ reflect ÂäüËÉΩÁöÑÔºåÂèØ‰ª•ÈÄöËøá reflect Â∫ìÂú®ËøêË°åÊó∂Âä®ÊÄÅÂú∞Êé¢Á¥¢ÂíåÊìç‰ΩúÂØπË±°ÁöÑÁ±ªÂûã„ÄÅÂÄºÂíåÁªìÊûÑ„ÄÇ‰ΩøÁî® reflect ÂèØ‰ª•ËÆøÈóÆ struct ÁöÑÂ≠óÊÆµ„ÄÅÊñπÊ≥ï„ÄÅÂáΩÊï∞Á≠â„ÄÇ

Ê≠§Â§ñ Golang ÁöÑ struct Êúâ‰∏Ä‰∏™ÁâπÊÆäÁöÑÂäüËÉΩ Âè´ÂÅö Struct TagÔºö

```go
type User struct {
    ID        int    `sqlType:"serial" sql:"PRIMARY KEY" json:"id"`
    Username  string `sql:"NOT NULL CHECK (username <> '')" json:"username"`
    Nickname  string `sql:"NOT NULL CHECK (nickname <> '')" json:"nickname"`
    Password  string `sql:"NOT NULL" json:"-"`
    Usergroup int    `sql:"CHECK (usergroup BETWEEN 0 AND 3)" json:"usergroup"`
}
```

ÊØîÂ¶Ç‰∏äËø∞‰ª£Á†ÅÊØè‰∏™Â≠óÊÆµÂè≥‰æßÁî®ÂèçÂºïÂè∑ÂåÖË£πÁöÑÈÉ®ÂàÜÂç≥‰∏∫ Struct Tag„ÄÇ

ÊàëÂÆûÁé∞ÁöÑ ORM Âü∫‰∫é reflect Âª∫Á´ã‰∫Ü **ÁªìÊûÑ‰ΩìÂêçÁß∞** ‰∏é **Ë°®Âêç** ‰πãÈó¥ÁöÑÊò†Â∞Ñ‰ª•Âèä **ÁªìÊûÑ‰ΩìÂ≠óÊÆµÂêçÂíåÁ±ªÂûã** ‰∏éË°® **ÂàóÂêçÂíåÂàóÁ±ªÂûã** ‰πãÈó¥ÁöÑÊò†Â∞ÑÔºåÂπ∂ÈÄöËøá reflect ËØªÂèñ **Struct Tag** ÂÆûÁé∞‰∫ÜÈ¢ùÂ§ñÁöÑ **Á∫¶ÊùüÊù°‰ª∂** ÁöÑÊ∑ªÂä†„ÄÇ

È©ºÂ≥∞ÂëΩÂêç‰∏é‰∏ãÂàíÁ∫øÂàÜÂâ≤ÂêçÁß∞ÁöÑËΩ¨Êç¢ `internal/utils/utils.go:11`Ôºö

```go
var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")

// ToSnakeCase turn the string to snake case
func ToSnakeCase(str string) string {
    snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
    snake  = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
    return strings.ToLower(snake)
}
```

Á±ªÂûãÊò†Â∞Ñ `internal/db/type_mapping.go:8`Ôºö

```go
func GetSQLType(field reflect.StructField) string {
    var sqlType string
    if sqlType = field.Tag.Get("sqlType"); len(sqlType) == 0 {
        switch field.Type.Kind() {
        case reflect.Bool:
            sqlType = "bool"
        case reflect.Int8, reflect.Uint8, reflect.Int16, reflect.Uint16:
            sqlType = "smallint"
        case reflect.Int32, reflect.Uint32:
            sqlType = "integer"
        case reflect.Int, reflect.Int64, reflect.Uint, reflect.Uint64:
            sqlType = "bigint"
        case reflect.Float32:
            sqlType = "real"
        case reflect.Float64:
            sqlType = "double precision"
        case reflect.String:
            sqlType = "text"
        default:
            if field.Type == reflect.TypeOf(time.Time{}) {
                sqlType = "timestampz"
            }
            // TODO
        }
    } else {
        if sqlType == "serial" {
            switch field.Type.Kind() {
            case reflect.Int8, reflect.Uint8, reflect.Int16, reflect.Uint16:
                sqlType = "smallserial"
            case reflect.Int32, reflect.Uint32:
                sqlType = "serial"
            case reflect.Int, reflect.Int64, reflect.Uint, reflect.Uint64:
                sqlType = "bigserial"
            }
        }
    }
    return sqlType
}
```

Âª∫Ë°®„ÄÅÊü•ËØ¢„ÄÅÊõ¥Êñ∞„ÄÅÂà†Èô§Á≠â `internal/db/database.go:66`Ôºà‰ª£Á†ÅËøáÈïøÔºåÊ≠§Â§Ñ‰ªÖÂàóÂá∫ÂÖ≥ÈîÆÊñπÊ≥ïÁ≠æÂêçÔºâÔºö

```go

// ------ ‚Üì ORM ‚Üì ------

// Base on the type of the argument
// the type of `value` should be the pointer of a struct

// CreateTable creates tables based on the type of each one value of values if not exist
func (db *DBHelper) CreateTable(value any) error

// Insert inserts value to the corresponding table according to its type
// cols represents the columns should be used (empty for using all fields)
func (db *DBHelper) Insert(value interface{}, cols ...string) (sql.Result, error)

func (db *DBHelper) Update(value interface{}, primaryKey int, cols ...string) (sql.Result, error)

func (db *DBHelper) Delete(dest interface{}, conds ...interface{}) (sql.Result, error)

// First
// dest: the pointer to a struct
// conds:
//
//	if it only contains a integer: primary key
//	if it only contains a string: query str
//	if it contains many string:
//	  conds[0]: query: query str
//	  conds[1:]: args: query args
func (db *DBHelper) First(dest interface{}, conds ...interface{}) error

// dest is the pointer of a empty slice
func (db *DBHelper) Query(dest interface{}, conds ...interface{}) error
```

ÊâÄÊúâÊìç‰ΩúÂùáË¢´Â∞ÅË£Ö‰∏∫‰∫ÜÂü∫‰∫é‰º†ÂÖ•ÂØπË±°Á±ªÂûãÁöÑÊñπÊ≥ïÔºåInsert„ÄÅUpdate„ÄÅDelete ‰ºöÂü∫‰∫é‰º†ÂÖ•ÁöÑ `value` Âú®ÂØπÂ∫îË°®ËøõË°å‰øÆÊîπÔºåQuery ‰ºöÂü∫‰∫é dest ÁöÑÁ±ªÂûãÂú®ÂØπÂ∫îË°®Êü•ËØ¢Âπ∂Â∞ÜÁªìÊûúÂ≠òÂÖ• dest„ÄÇ

ÁÑ∂Âêé‰ΩøÁî®ËøôÂ•óÊ°ÜÊû∂Âç≥ÂèØÈ´òÂ∫¶ÁÆÄÂåñÂêÑ‰∏™ÊúçÂä°ÁöÑ‰ª£Á†Å `server/service/*.go`Ôºå‰∏ãÈù¢‰ª•ÂàõÂª∫ËØæÁ®ãÊñπÊ≥ï `server/service/course.go:11` ‰∏∫‰æãÔºö

```go
type CreateCourseService struct {
	Name        string `form:"name"`
	Description string `form:"description"`
	IsPrivate   bool   `form:"is_private"`
}

func (s *CreateCourseService) Handle(c *gin.Context) (any, error) {
    // Get id of the current user

    id := c.GetInt("id")

	course := &models.Course{
        CreaterID:   id,
		Name:        s.Name,
		Description: s.Description,
		IsPrivate:   s.IsPrivate,
	}

	res, err := bootstrap.DB.Insert(course)
	if err != nil {
		log.Printf("[CreateCourseService]: Error %v\n", err)
		return nil, err
	}
	log.Printf("[CreateCourseService]: Service created %v\n", res)

	return nil, nil
}
```

ÂÜçÊØîÂ¶ÇÁî®Êà∑ÁôªÂΩï `server/service/user.go:39`Ôºö

```go
type LoginService struct {
    Username string `form:"username"`
    Password string `form:"password"`
}

func (s *LoginService) Handle(c *gin.Context) (any, error) {
    var err error
    user := &models.User{}
    log.Println("[LoginService/Handle]: Getting first record that matches the username...")
    if err = bootstrap.DB.First(user, "username LIKE $1", s.Username); err != nil {
        return nil, err // User not exist
    }
    log.Printf("[LoginService/Handle]: User: %v\n", user)

    log.Println("[LoginService/Handle]: Checking password...")
    if err := user.CheckPassword(s.Password); err != nil {
        return nil, err
    }
    log.Println("[LoginService/Handle]: Password correct")

	var jwtToken string
	jwtToken, err = jwt.CreateToken(user.ID, user.Usergroup)

	res := make(map[string]any)
	res["token"] = jwtToken
	res["user"] = user
	// res["user_name"] = user.Username

	return res, nil
}

```

#### > ÂêéÁ´ØÂ≠òÂÇ®ÂØÜÁ†Å ÂìàÂ∏å + Âä†Áõê ‰∏é JWT

‰∏äÈù¢Â∑≤ÁªèÂ±ïÁ§∫‰∫ÜÁî®Êà∑ÁôªÈôÜÈÉ®ÂàÜ‰ª£Á†ÅÔºå‰ºö‰ªéÊï∞ÊçÆÂ∫ì‰∏≠ÂèñÂá∫ÂØπÂ∫îÁî®Êà∑ÁöÑÁõêÂÄºÂπ∂‰ΩøÁî®Áõ∏ÂêåÁöÑÂä†ÂØÜÁÆóÊ≥ïÂØπ‰º†ÂÖ•ÁöÑÂØÜÁ†ÅËøõË°åÂä†ÂØÜÔºåÂÜçÂ∞ÜÁªìÊûú‰∏éÊï∞ÊçÆÂ∫ì‰∏≠ÁöÑÂÄºËøõË°åÂØπÊØîÔºåÂ¶ÇÊûúÊ≠£Á°ÆÔºåÂàôÁîüÊàê‰∏Ä‰∏™ JWT token ‰º†ÁªôÂÆ¢Êà∑Á´Ø

### 3. ÊïàÊûúÂ±ïÁ§∫

Ê≥®ÂÜåÔºö

![image-20230619190645033](imgs/image-20230619190645033.png)

![image-20230619190655071](imgs/image-20230619190655071.png)

ÁôªÂΩïÔºö

![image-20230619190707688](imgs/image-20230619190707688.png)

È¶ñÈ°µÔºö

![image-20230619190836283](imgs/image-20230619190836283.png)

![image-20230619190907445](imgs/image-20230619190907445.png)

ÔºàÁßÅÊúâËØæÁ®ãÂäüËÉΩÊ≤°ÊúâÂÆûÈôÖÂÆûÁé∞Ôºâ

![image-20230619190932936](imgs/image-20230619190932936.png)

Âä†ÂÖ•ËØæÁ®ãÔºö

![image-20230619190958751](imgs/image-20230619190958751.png)

‰øÆÊîπËØæÁ®ãÔºö

![image-20230619191016337](imgs/image-20230619191016337.png)

![image-20230619191020306](imgs/image-20230619191020306.png)

![image-20230619191025307](imgs/image-20230619191025307.png)

SQL ÊâßË°åÔºö

![image-20230619191041879](imgs/image-20230619191041879.png)

ÈÄÄÂá∫ËØæÁ®ãÔºö

![image-20230619191116681](imgs/image-20230619191116681.png)